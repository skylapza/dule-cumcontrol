<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dule CumControl - Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/game_styles.css"> <!-- Link to external CSS, assuming it exists -->
    <style>
        /* ************************************************* */
        /* Custom styles for master_control.html to emphasize camera */
        /* and center everything */
        /* ************************************************* */

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a0033, #32004d, #4d0066);
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            overflow-x: hidden;
        }

        .game-area-container.master-area {
            max-width: 900px;
            padding: 20px;
            gap: 15px;
            background: rgba(46, 46, 46, 0.8);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
        }

        h1 {
            color: #ffccff;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 204, 255, 0.5);
            margin-bottom: 20px;
        }

        .all-videos-container {
            display: flex;
            flex-direction: column; /* Stacks remote and local video sections */
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between video sections */
            width: 100%;
            margin-bottom: 1.5rem;
        }

        .video-element {
            width: 100%; /* Each video takes full width of its container */
            max-width: 450px; /* Limit max width for each video */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 16 / 9;
            background-color: #2a3547;
            border-radius: 0.75rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
            object-fit: cover;
            border: 2px solid #60a5fa;
            display: none; /* Hide video elements by default */
        }

        @media (max-width: 767px) {
            .video-element {
                max-width: 100%; /* Full width on smaller screens */
            }
        }

        /* Common button styles */
        button {
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
            border-radius: 0.75rem;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        button:hover:enabled {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }

        /* Camera control buttons */
        .camera-controls button {
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            border-radius: 0.6rem;
        }

        /* Timer text */
        #masterGameTimer {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #b3e0ff;
            font-weight: 600;
        }

        /* BPM control group */
        .bpm-control-group {
            margin: 1.5rem auto;
            max-width: 400px;
            width: 90%;
            background: rgba(30, 30, 30, 0.6);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #masterBpmDisplay {
            font-size: 1.8em;
            font-weight: 700;
            color: #90ee90; /* Light green */
            margin-bottom: 0.5rem;
        }
        .bpm-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            width: 100%;
        }
        .bpm-buttons button {
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 150px; /* Limit button width */
            padding: 0.6rem 1rem;
            font-size: 0.9em;
            border-radius: 0.6rem;
        }
        #increaseBpmBtn { background-color: #28a745; } /* Green */
        #decreaseBpmBtn { background-color: #ffc107; } /* Yellow */
        #stopBpmBtn { background-color: #dc3545; } /* Red */

        /* Player Arousal Display on Master's screen */
        .player-arousal-group {
            margin: 1.5rem auto;
            max-width: 400px;
            width: 90%;
            background: rgba(30, 30, 30, 0.6);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        #playerArousalStatus {
            font-size: 1.1em;
            font-weight: 700;
            color: #ff5252;
        }
        .arousal-bar-container {
            height: 1.2rem;
            margin-top: 0.6rem;
            background-color: #4a4a4a;
            border-radius: 0.6rem;
        }
        #playerArousalBarForMaster {
            background-color: #f44336;
        }
        .arousal-max-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }


        /* Master Command Buttons */
        .master-controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Two columns */
            gap: 1rem; /* Space between buttons */
            margin: 1.5rem auto;
            max-width: 600px;
            width: 100%;
            padding: 0 10px; /* Add some horizontal padding */
        }
        @media (max-width: 480px) {
            .master-controls-grid {
                grid-template-columns: 1fr; /* Single column on very small screens */
            }
        }
        .master-controls-grid button {
            padding: 1rem;
            font-size: 1.1rem;
            border-radius: 0.75rem;
            text-align: center;
        }
        #masterOkBtn { background-color: #007bff; } /* Blue */
        #masterNoBtn { background-color: #ffc107; } /* Yellow */
        #masterCumNowBtn { background-color: #28a745; } /* Green */
        #masterDontTouchBtn { background-color: #dc3545; } /* Red */


        /* Player Request Display on Master's screen */
        #playerRequestBox {
            background-color: rgba(60, 60, 60, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-top: 1.5rem;
            min-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
            font-weight: 600;
            color: #ffeb3b; /* Yellow for requests */
            text-shadow: 0 0 5px rgba(255, 235, 59, 0.4);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        /* Notification area (consistent with lobby and player_game) */
        #messageBox {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 1em;
            max-width: 400px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 1000;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        #messageBox.show {
            opacity: 1;
            visibility: visible;
        }
        #messageBox.success {
            background-color: rgba(0, 128, 0, 0.3);
        }
        #messageBox.info {
            background-color: rgba(0, 100, 200, 0.3);
        }

        /* Back to Lobby button */
        #backToLobbyBtnMaster {
            background-color: #4a5568;
            color: #cbd5e0;
            border-bottom: 1px solid #718096;
            text-decoration: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            margin-top: 2rem;
        }
        #backToLobbyBtnMaster:hover {
            background-color: #2d3748;
            color: #edf2f7;
            text-decoration: none;
        }

        /* Headings above videos */
        .video-label-container {
            text-align: center;
            margin-bottom: 0.5rem;
            color: #b3e0ff;
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="messageBox" class="message-box"></div>

    <div class="max-w-2xl game-area-container master-area">
        <h1 class="text-3xl font-bold text-center mb-4">Master</h1>

        <p id="masterGameTimer" class="text-lg">‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: 00:00</p>

        <div class="flex justify-center gap-4 my-4 camera-controls">
            <button id="masterOpenCameraBtn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button id="masterSwapCameraBtn" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded">‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button id="masterStopCameraBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
        </div>

        <div class="all-videos-container">
            <!-- Remote Video (Player's camera) -->
            <div>
                <h3 class="video-label-container">‡∏Å‡∏•‡πâ‡∏≠‡∏á Player</h3>
                <video id="remoteVideo" class="video-element" autoplay playsinline></video>
            </div>

            <!-- Local Video (Your camera) -->
            <div>
                <h3 class="video-label-container">‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</h3>
                <video id="localVideo" class="video-element" autoplay playsinline muted></video>
            </div>
        </div>

        <div class="text-center mb-6 bpm-control-group">
            <div id="masterBpmDisplay" class="text-2xl font-bold">BPM: 100</div>
            <div class="flex justify-center gap-4 bpm-buttons">
                <button id="decreaseBpmBtn" class="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded">‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</button>
                <button id="increaseBpmBtn" class="bg-green-500 hover:bg-green-600 px-4 py-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</button>
                <button id="stopBpmBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">‡∏´‡∏¢‡∏∏‡∏î/‡πÄ‡∏£‡∏¥‡πà‡∏°</button>
            </div>
        </div>

        <div class="text-center mb-6 player-arousal-group">
            <div id="playerArousalStatus" class="text-lg font-bold">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô Player: 5/10</div>
            <div class="w-full bg-gray-600 h-5 rounded relative overflow-hidden my-2 arousal-bar-container">
                <div id="playerArousalBarForMaster" class="bg-red-500 h-full transition-all duration-300" style="width: 50%"></div>
                <span class="absolute right-2 top-1/2 -translate-y-1/2 text-xs arousal-max-label">CUM</span>
            </div>
        </div>

        <div id="playerRequestBox" class="text-center font-bold text-yellow-400 my-4">
            ‡∏£‡∏≠‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏à‡∏≤‡∏Å Player...
        </div>

        <div class="master-controls-grid">
            <button id="masterOkBtn" class="bg-blue-500 hover:bg-blue-600 rounded">OK</button>
            <button id="masterNoBtn" class="bg-yellow-500 hover:bg-yellow-600 rounded">NO</button>
            <button id="masterCumNowBtn" class="bg-green-500 hover:bg-green-600 rounded">CUM NOW</button>
            <button id="masterDontTouchBtn" class="bg-red-500 hover:bg-red-600 rounded">DON'T TOUCH!</button>
        </div>

        <div class="text-center mt-8">
            <button id="backToLobbyBtnMaster" class="underline text-sm">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Global socket connection
        const socket = io();

        // Global variables for WebRTC and game state
        let peerConnection;
        let localStream;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let videoSender = null; // To store the RTCRtpSender for the video track for replaceTrack
        let myRoom; // NEW: Global variable for current room
        let myRole; // NEW: Global variable for current role

        // WebRTC Config with STUN servers
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        // Master Game Logic variables
        let currentBpm = 100; // Master controls BPM
        let bpmInterval; // Interval ID for sending BPM updates to player
        let masterElapsedTime = 0;
        let masterElapsedTimeInterval = null; // Interval ID for game timer

        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const masterGameTimer = document.getElementById('masterGameTimer');
        const masterBpmDisplay = document.getElementById('masterBpmDisplay');
        const increaseBpmBtn = document.getElementById('increaseBpmBtn');
        const decreaseBpmBtn = document.getElementById('decreaseBpmBtn');
        const stopBpmBtn = document.getElementById('stopBpmBtn');
        const playerArousalStatus = document.getElementById('playerArousalStatus');
        const playerArousalBarForMaster = document.getElementById('playerArousalBarForMaster');
        const playerRequestBox = document.getElementById('playerRequestBox');
        const masterOkBtn = document.getElementById('masterOkBtn');
        const masterNoBtn = document.getElementById('masterNoBtn');
        const masterCumNowBtn = document.getElementById('masterCumNowBtn');
        const masterDontTouchBtn = document.getElementById('masterDontTouchBtn');
        const backToLobbyBtnMaster = document.getElementById('backToLobbyBtnMaster');
        const masterOpenCameraBtn = document.getElementById('masterOpenCameraBtn');
        const masterSwapCameraBtn = document.getElementById('masterSwapCameraBtn');
        const masterStopCameraBtn = document.getElementById('masterStopCameraBtn');
        const messageBox = document.getElementById('messageBox'); // For custom notifications


        // Function to play sound (if needed for Master actions)
        function playSound(soundFile) {
            try {
                const audio = new Audio(soundFile);
                audio.volume = 0.5;
                audio.play().catch(e => console.warn("Cannot play audio: ", e));
            } catch (e) {
                console.error("Error creating audio object:", e);
            }
        }

        // Function to display custom messages (consistent with other pages)
        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = 'message-box show'; // Reset classes and show
            messageBox.classList.add(type); // Add specific type class for styling
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }

        // Function to update BPM display and send to player
        function updateMasterBpmDisplay() {
            masterBpmDisplay.textContent = `BPM: ${currentBpm}`;
            // Only send BPM if it's not 0 (stopped)
            if (currentBpm > 0) {
                socket.emit('masterCommand', { room: myRoom, type: 'bpm_update', bpm: currentBpm });
                // Clear and restart the BPM interval for precise timing
                if (bpmInterval) clearInterval(bpmInterval);
                bpmInterval = setInterval(() => {
                    // This interval will trigger the animation on player side.
                    // Master just sends the BPM value.
                }, 60000 / currentBpm); // Interval matches the BPM
            } else {
                // If BPM is 0, stop sending updates and clear interval
                if (bpmInterval) clearInterval(bpmInterval);
                bpmInterval = null;
                socket.emit('masterCommand', { room: myRoom, type: 'bpm_stop', message: 'Master ‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î!' });
            }
        }

        // Camera and WebRTC Functions (similar to player_game.html)
        async function startCamera(facingMode = 'user') {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null;
            }
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode },
                    audio: true // Master also needs to send audio
                });
                localVideo.srcObject = localStream;
                localVideo.style.display = 'block';
                currentFacingMode = facingMode;
                showMessage("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'success');

                if (peerConnection) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    const audioTrack = localStream.getAudioTracks()[0];

                    if (videoTrack) {
                        if (videoSender && videoSender.track.kind === 'video') { // Check if sender is for video
                            await videoSender.replaceTrack(videoTrack);
                            console.log('Replaced video track in peer connection');
                        } else {
                            // Find existing video sender or add new one
                            let existingVideoSender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (existingVideoSender) {
                                await existingVideoSender.replaceTrack(videoTrack);
                                videoSender = existingVideoSender; // Update videoSender reference
                            } else {
                                videoSender = peerConnection.addTrack(videoTrack, localStream);
                                console.log('Added video track for the first time to peer connection');
                            }
                        }
                    }
                    if (audioTrack) {
                        let existingAudioSender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'audio');
                        if (existingAudioSender) {
                             await existingAudioSender.replaceTrack(audioTrack);
                        } else {
                             peerConnection.addTrack(audioTrack, localStream);
                             console.log('Added audio track for the first time to peer connection');
                        }
                    }
                }
            } catch (e) {
                console.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ: ", e);
                let errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ";
                if (e.name === "NotAllowedError") {
                    errorMessage += ": ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Ç‡∏≠‡∏á‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå)";
                } else if (e.name === "NotFoundError") {
                    errorMessage += ": ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á";
                } else {
                    errorMessage += `: ${e.message}`;
                }
                showMessage(errorMessage, 'error');
            }
        }

        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                localVideo.style.display = 'none';
                showMessage("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'info');
            }
        }

        async function switchCamera() {
            const newFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            await startCamera(newFacingMode);
        }

        // WebRTC Setup: Create Peer Connection
        function createPeerConnection() {
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                console.warn("Peer connection already exists and is not closed. Skipping creation.");
                return;
            }

            peerConnection = new RTCPeerConnection(rtcConfig);
            console.log("RTCPeerConnection created.");

            // Add local stream tracks to peer connection if available
            if (localStream) {
                // Ensure existing senders are reused or updated
                localStream.getTracks().forEach(track => {
                    let sender = peerConnection.getSenders().find(s => s.track && s.track.kind === track.kind);
                    if (sender) {
                        sender.replaceTrack(track);
                        if (track.kind === 'video') videoSender = sender; // Update videoSender reference
                    } else {
                        const newSender = peerConnection.addTrack(track, localStream);
                        if (track.kind === 'video') videoSender = newSender; // Store video sender
                    }
                });
            }

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate);
                    socket.emit('signal', { room: myRoom, candidate: event.candidate }); // Pass myRoom
                }
            };

            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block';
                    showMessage('‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏à‡∏≤‡∏Å Player ‡πÅ‡∏•‡πâ‡∏ß', 'success');
                    console.log('Received remote stream from Player');
                }
            };

            peerConnection.onconnectionstatechange = (event) => {
                console.log('WebRTC connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    showMessage('‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebRTC ‡∏´‡∏•‡∏∏‡∏î/‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß', 'error');
                } else if (peerConnection.connectionState === 'connected') {
                    showMessage('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebRTC ‡∏Å‡∏±‡∏ö Player ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!', 'success');
                }
            };

            peerConnection.onsignalingstatechange = (event) => {
                console.log('WebRTC signaling state:', peerConnection.signalingState);
            };
        }

        // Socket.IO Listeners for WebRTC Signaling
        socket.on('paired', async ({ role, room }) => {
            showMessage('‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏°', 'success');
            // Store room and role globally
            myRoom = room;
            myRole = role;

            await startCamera(); // NEW: Master starts camera automatically when paired
            createPeerConnection(); // Create peer connection when paired

            // Master creates an offer and sends it to the player
            if (myRole === 'master') {
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    console.log('Sending WebRTC offer from Master:', offer);
                    socket.emit('signal', { room: myRoom, sdp: offer }); // Pass myRoom
                } catch (e) {
                    console.error("Error creating or sending offer:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏° WebRTC: " + e.message, 'error');
                }
            }
        });

        socket.on('signal', async (data) => {
            // Ensure myRoom is set before processing signals
            if (!myRoom && data.room) {
                myRoom = data.room; // Try to get room from incoming signal if not set
            }

            if (!peerConnection || peerConnection.signalingState === 'closed') {
                 await startCamera(); // Ensure camera/stream is ready before creating PC
                 createPeerConnection();
            }

            if (data.sdp) {
                console.log('Received SDP:', data.sdp.type);
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

                    if (data.sdp.type === 'answer') { // Master receives answer from Player
                        console.log('Received answer from Player.');
                        // No need to create another answer, just remote description is set
                    } else if (data.sdp.type === 'offer') { // Master should not receive offer, but handle defensively
                        console.warn('Received unexpected offer from Player.');
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        socket.emit('signal', { room: myRoom, sdp: answer }); // Pass myRoom
                        console.log('WebRTC answer sent (due to unexpected offer).');
                    }
                } catch (e) {
                    console.error("Error setting remote description or creating answer:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö/‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• WebRTC: " + e.message, 'error');
                }
            } else if (data.candidate) {
                console.log('Received ICE candidate:', data.candidate);
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ICE candidate: " + e.message, 'error');
                }
            }
        });

        // Handle partner disconnected
        socket.on('partnerDisconnected', (message) => {
            showMessage(message + "\n‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ", 'info');
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                peerConnection.close();
                peerConnection = null;
                videoSender = null;
            }
            stopCamera();
            remoteVideo.srcObject = null;
            remoteVideo.style.display = 'none';
            if (masterElapsedTimeInterval) {
                clearInterval(masterElapsedTimeInterval);
                masterElapsedTimeInterval = null;
            }
            if (bpmInterval) {
                clearInterval(bpmInterval);
                bpmInterval = null;
            }
            // Reset BPM display and player arousal display
            masterBpmDisplay.textContent = `BPM: 0`;
            playerArousalStatus.textContent = `‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô Player: --/10`;
            playerArousalBarForMaster.style.width = `0%`;

            setTimeout(() => {
                window.location.href = '/lobby.html';
            }, 3000);
        });


        // --- Event Listeners for DOM elements ---
        document.addEventListener('DOMContentLoaded', () => {
            // NEW: Initialize myRoom and myRole from URL parameters on page load
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('room') && urlParams.has('role')) {
                myRoom = parseInt(urlParams.get('room'));
                myRole = urlParams.get('role');
                console.log(`Initialized from URL: Room ${myRoom}, Role ${myRole}`);
            }

            updateMasterBpmDisplay(); // Initial display update
            // Start Master's game timer (adjust this to be triggered by game start signal from server)
            let seconds = 0;
            masterElapsedTimeInterval = setInterval(() => {
                seconds++;
                const m = String(Math.floor(seconds / 60)).padStart(2, '0');
                const s = String(seconds % 60).padStart(2, '0');
                masterGameTimer.textContent = `‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: ${m}:${s}`;
            }, 1000);


            increaseBpmBtn.addEventListener('click', () => {
                currentBpm = Math.min(currentBpm + 10, 200); // Max BPM 200
                updateMasterBpmDisplay();
                showMessage(`‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏õ‡πá‡∏ô: ${currentBpm} BPM`, 'info');
            });

            decreaseBpmBtn.addEventListener('click', () => {
                currentBpm = Math.max(currentBpm - 10, 0); // Min BPM 0
                updateMasterBpmDisplay();
                showMessage(`‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏õ‡πá‡∏ô: ${currentBpm} BPM`, 'info');
            });

            stopBpmBtn.addEventListener('click', () => {
                if (currentBpm > 0) {
                    currentBpm = 0; // Stop BPM
                    showMessage('‡∏´‡∏¢‡∏∏‡∏î BPM!', 'info');
                } else {
                    currentBpm = 100; // Resume to default BPM
                    showMessage('‡πÄ‡∏£‡∏¥‡πà‡∏° BPM!', 'success');
                }
                updateMasterBpmDisplay(); // This will also send bpm_stop/bpm_start command
            });

            masterOpenCameraBtn.addEventListener('click', () => startCamera());
            masterSwapCameraBtn.addEventListener('click', switchCamera);
            masterStopCameraBtn.addEventListener('click', stopCamera);

            masterOkBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { room: myRoom, type: 'ok', message: 'Master: OK! üëå' }); // Pass myRoom
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: OK!', 'success');
            });
            masterNoBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { room: myRoom, type: 'no', message: 'Master: NO! üôÖ' }); // Pass myRoom
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: NO!', 'success');
            });
            masterCumNowBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { room: myRoom, type: 'cum_now', message: 'Master ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏´‡∏•‡∏±‡πà‡∏á! üí¶üí¶üí¶' }); // Pass myRoom
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: CUM NOW!', 'success');
            });
            masterDontTouchBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { room: myRoom, type: 'dont_touch', message: 'Master: ‡∏´‡πâ‡∏≤‡∏°‡πÅ‡∏ï‡∏∞! ‚õî' }); // Pass myRoom
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: DON\'T TOUCH!', 'success');
            });

            backToLobbyBtnMaster.addEventListener('click', () => {
                showMessage("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ...", 'info');
                socket.emit('leaveRoom');
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    peerConnection.close();
                    peerConnection = null;
                    videoSender = null;
                }
                stopCamera();
                remoteVideo.srcObject = null;
                remoteVideo.style.display = 'none';
                if (masterElapsedTimeInterval) {
                    clearInterval(masterElapsedTimeInterval);
                    masterElapsedTimeInterval = null;
                }
                if (bpmInterval) {
                    clearInterval(bpmInterval);
                    bpmInterval = null;
                }
                setTimeout(() => {
                    window.location.href = '/lobby.html';
                }, 1500);
            });
        });

        // Socket.IO Listeners for commands from Player
        socket.on('playerCommand', (data) => {
            console.log("Master received command from Player:", data);
            playerRequestBox.textContent = data.message;
            showMessage(`‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠: ${data.message}`, 'info');
            // Clear message after a short delay
            setTimeout(() => {
                playerRequestBox.textContent = '‡∏£‡∏≠‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏à‡∏≤‡∏Å Player...';
            }, 5000);
        });

        // Socket.IO Listener for Player's Arousal Update
        socket.on('playerArousalUpdate', (arousalLevel) => {
            console.log("Master received Player Arousal Update:", arousalLevel);
            playerArousalStatus.textContent = `‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô Player: ${arousalLevel}/10`;
            playerArousalBarForMaster.style.width = `${(arousalLevel / 10) * 100}%`;
        });

        // Handle initial connection or reconnection
        socket.on('connect', () => {
            console.log('Master connected to Socket.IO server.');
        });

        socket.on('disconnect', () => {
            console.log('Master disconnected from Socket.IO server.');
        });
    </script>
</body>
</html>
