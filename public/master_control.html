<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dule CumControl - Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/game_styles.css"> <!-- Link to external CSS, assuming it exists -->
    <style>
        /* ************************************************* */
        /* Custom styles for master_control.html */
        /* ************************************************* */

        /* Override body styles for consistent background and centering */
        body {
            font-family: 'Inter', sans-serif; /* Consistent font with other pages */
            background: linear-gradient(135deg, #1a0033, #32004d, #4d0066); /* Consistent gradient */
            color: #e0e0e0; /* Softer white */
            display: flex;
            flex-direction: column; /* Ensure content stacks vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            min-height: 100vh; /* Ensure full viewport height */
            padding: 20px; /* Add padding for overall content */
            margin: 0; /* Remove body margin */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        .game-area-container.master-area {
            max-width: 900px; /* Max width of the Master game area */
            padding: 20px; /* Reduced padding */
            gap: 15px; /* Reduced spacing between elements */
            background: rgba(46, 46, 46, 0.8); /* Consistent background with lobby rooms */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5); /* Deep shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            width: 100%; /* Take full width on smaller screens */
        }

        h1 {
            color: #ffccff;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 204, 255, 0.5);
            margin-bottom: 20px;
        }

        /* Style for the video elements to be responsive and larger */
        .video-display-area { /* Container for local and remote videos */
            display: flex;
            flex-direction: column; /* Stack videos vertically by default */
            justify-content: center; /* Center videos */
            align-items: center; /* Center videos horizontally */
            gap: 1.5rem; /* Space between videos */
            width: 100%; /* Use full width */
            margin-bottom: 1.5rem;
        }

        .video-element {
            width: 100%; /* Each video takes full width of its container */
            max-width: 450px; /* Limit max width for each video */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 16 / 9;
            background-color: #2a3547; /* Darker grey background */
            border-radius: 0.75rem; /* Rounded corners (rounded-lg) */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25); /* Prominent shadow */
            object-fit: cover; /* Cover video area */
            border: 2px solid #60a5fa; /* Blue border */
            display: none; /* Hide video elements by default */
        }

        /* Responsive adjustments for videos */
        @media (min-width: 768px) {
            .video-display-area {
                flex-direction: row; /* Arrange videos side-by-side on larger screens */
                justify-content: space-around; /* Distribute space evenly */
                gap: 2rem;
            }
            .video-element {
                max-width: 45%; /* Adjust width to fit two videos side by side */
            }
        }
        @media (max-width: 767px) {
            .video-element {
                width: 100%; /* Full width of video-display-area */
                max-width: 450px; /* Max width to prevent excessive size */
            }
        }

        /* Common button styles */
        button {
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
            border-radius: 0.75rem; /* Consistent rounded corners */
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        button:hover:enabled {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }

        /* Camera control buttons */
        .camera-controls button {
            padding: 0.6rem 1.2rem; /* Adjusted padding */
            font-size: 0.95rem; /* Adjusted font size */
            border-radius: 0.6rem; /* Adjusted rounded corners */
        }

        /* Timer text */
        #masterGameTimer {
            font-size: 1.2rem; /* Adjusted font size */
            margin-bottom: 1rem;
            color: #b3e0ff; /* Consistent color with lobby */
            font-weight: 600;
        }

        /* BPM display */
        .master-bpm-display-group,
        .arousal-display-group {
            margin: 1.5rem auto; /* Center horizontally, adjusted top/bottom margin */
            max-width: 400px; /* Increased max-width */
            width: 90%; /* Use more width on smaller screens */
            background: rgba(30, 30, 30, 0.6); /* Slightly darker background */
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .master-bpm-display-group div,
        .arousal-display-group div {
            margin-bottom: 0.5rem;
        }
        #masterBpmDisplay,
        #masterArousalDisplay {
            font-size: 1.1em;
            font-weight: 700;
            color: #ffeb3b; /* Yellow for BPM */
        }
        #masterArousalDisplay {
            color: #ff5252; /* Red for Arousal */
        }
        .master-bpm-bar-container,
        .arousal-bar-container {
            height: 1.2rem; /* Slightly taller bar */
            margin-top: 0.6rem;
            background-color: #4a4a4a; /* Darker track */
            border-radius: 0.6rem;
        }
        #masterBpmBar {
            background-color: #9c27b0; /* Deeper purple */
        }
        #masterArousalBar {
            background-color: #f44336; /* Vibrant red */
        }
        .master-bpm-buttons button,
        .arousal-buttons button {
            padding: 0.6rem 1rem;
            font-size: 0.9em;
            border-radius: 0.6rem;
            margin: 0.2rem; /* Add small margin for button spacing */
        }
        .master-bpm-max-label,
        .arousal-max-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Master action buttons */
        .master-action-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem; /* Increased gap */
            margin: 1.5rem auto;
            max-width: 600px; /* Increased max width for more buttons */
        }
        .master-action-group button {
            padding: 0.8rem 1.6rem; /* Consistent button size */
            font-size: 1.1rem; /* Slightly larger text */
            border-radius: 0.75rem;
            min-width: 120px; /* Ensure minimum width for buttons */
        }
        .master-control-btn.cum-now-btn {
            background-color: #1a9e4d; /* Darker green */
            transition: background-color 0.3s ease;
        }
        .master-control-btn.cum-now-btn:hover {
            background-color: #24b860;
        }
        .master-control-btn.dont-touch-btn {
            background-color: #d97706; /* Darker orange */
            transition: background-color 0.3s ease;
        }
        .master-control-btn.dont-touch-btn:hover {
            background-color: #fb923c;
        }

        /* Notification area (consistent with lobby) */
        #messageBox {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.3); /* Reddish for error */
            border-radius: 8px;
            color: white;
            font-size: 1em;
            max-width: 400px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 1000; /* Ensure it's on top */
            position: fixed; /* Fixed position */
            top: 20px; /* From top */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust for perfect centering */
        }
        #messageBox.show {
            opacity: 1;
            visibility: visible;
        }
        #messageBox.success {
            background-color: rgba(0, 128, 0, 0.3); /* Greenish for success */
        }
        #messageBox.info {
            background-color: rgba(0, 100, 200, 0.3); /* Bluish for info */
        }

        /* Back to Lobby button */
        #backToLobbyBtnMaster {
            background-color: #4a5568; /* Darker gray for subtle look */
            color: #cbd5e0;
            border-bottom: 1px solid #718096; /* Subtle underline effect */
            text-decoration: none; /* Remove default underline */
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            margin-top: 2rem;
        }
        #backToLobbyBtnMaster:hover {
            background-color: #2d3748;
            color: #edf2f7;
            text-decoration: none;
        }

        /* Headings above videos */
        .video-display-area h3 {
            text-align: center;
            margin-bottom: 0.5rem;
            color: #b3e0ff; /* Light blue for video titles */
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="messageBox" class="message-box"></div>

    <div class="max-w-2xl game-area-container master-area">
        <h1 class="text-3xl font-bold text-center mb-4">Master</h1>
        <p id="masterGameTimer" class="text-lg">‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: 00:00</p>

        <div class="flex justify-center gap-4 my-4 camera-controls">
            <button id="masterOpenCameraBtn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button id="masterSwapCameraBtn" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded">‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button id="masterStopCameraBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
        </div>

        <div class="video-display-area">
            <div>
                <h3>‡∏Å‡∏•‡πâ‡∏≠‡∏á Player</h3>
                <video id="remoteVideo" class="video-element" autoplay playsinline></video>
            </div>
            <div>
                <h3>‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</h3>
                <video id="localVideo" class="video-element" autoplay playsinline muted></video>
            </div>
        </div>

        <!-- Master's command buttons -->
        <div class="master-action-group">
            <button id="masterOkBtn" class="bg-blue-600 hover:bg-blue-700 master-control-btn">Ok ‚úÖ</button>
            <button id="masterNoBtn" class="bg-red-600 hover:bg-red-700 master-control-btn">No ‚ùå</button>
            <button id="masterCumNowBtn" class="bg-green-600 hover:bg-green-700 master-control-btn cum-now-btn">Cum Now üí¶</button>
            <button id="masterDontTouchBtn" class="bg-orange-600 hover:bg-orange-700 master-control-btn dont-touch-btn">Don't Touch üö´</button>
        </div>

        <!-- Master's BPM Gauge -->
        <div class="text-center master-bpm-display-group">
            <div id="masterBpmDisplay">BPM: 120</div>
            <div class="w-full h-5 rounded relative overflow-hidden master-bpm-bar-container">
                <div id="masterBpmBar" class="h-full transition-all duration-300" style="width: 50%;"></div>
                <span class="absolute right-2 top-1/2 -translate-y-1/2 master-bpm-max-label">MAX</span>
            </div>
            <div class="flex justify-center gap-4 master-bpm-buttons">
                <button id="decreaseBpmBtn" class="bg-yellow-500 hover:bg-yellow-600">‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</button>
                <button id="increaseBpmBtn" class="bg-green-500 hover:bg-green-600">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</button>
                <button id="stopBpmBtn" class="bg-gray-700 hover:bg-gray-600">‡∏´‡∏¢‡∏∏‡∏î/‡πÄ‡∏£‡∏¥‡πà‡∏°</button>
            </div>
        </div>

        <!-- Master's view of Player's Arousal -->
        <div class="text-center arousal-display-group">
            <div id="masterArousalDisplay">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏≠‡∏á Player: 5/10</div>
            <div class="w-full h-5 rounded relative overflow-hidden arousal-bar-container">
                <div id="masterArousalBar" class="h-full transition-all duration-300" style="width: 50%;"></div>
                <span class="absolute right-2 top-1/2 -translate-y-1/2 arousal-max-label">CUM</span>
            </div>
        </div>

        <div class="text-center mt-8">
            <button id="backToLobbyBtnMaster" class="underline text-sm">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Global socket connection
        const socket = io();

        // WebRTC related variables
        let peerConnection;
        let localStream;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let videoSender = null; // To store the RTCRtpSender for the video track for replaceTrack

        // Master Game Logic variables
        let masterBpmLevel = 5; // Master's BPM gauge level (1-10)
        const bpmLevels = [60, 80, 100, 120, 140, 160, 180, 200, 240, 280]; // Corresponding BPM values
        const maxBpmLevel = 10;
        let isBpmStopped = false; // New state variable to track if BPM is stopped
        let masterElapsedTimeInterval = null; // Interval ID for game timer

        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const masterGameTimer = document.getElementById('masterGameTimer');
        const masterBpmDisplay = document.getElementById('masterBpmDisplay');
        const masterBpmBar = document.getElementById('masterBpmBar');
        const increaseBpmBtn = document.getElementById('increaseBpmBtn');
        const decreaseBpmBtn = document.getElementById('decreaseBpmBtn');
        const stopBpmBtn = document.getElementById('stopBpmBtn');
        const masterOkBtn = document.getElementById('masterOkBtn');
        const masterNoBtn = document.getElementById('masterNoBtn');
        const masterCumNowBtn = document.getElementById('masterCumNowBtn');
        const masterDontTouchBtn = document.getElementById('masterDontTouchBtn');
        const masterArousalDisplay = document.getElementById('masterArousalDisplay');
        const masterArousalBar = document.getElementById('masterArousalBar');
        const backToLobbyBtnMaster = document.getElementById('backToLobbyBtnMaster');
        const masterOpenCameraBtn = document.getElementById('masterOpenCameraBtn');
        const masterSwapCameraBtn = document.getElementById('masterSwapCameraBtn');
        const masterStopCameraBtn = document.getElementById('masterStopCameraBtn');
        const messageBox = document.getElementById('messageBox'); // For custom notifications


        // Function to display custom messages (consistent with lobby.html)
        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = 'message-box show'; // Reset classes and show
            messageBox.classList.add(type); // Add specific type class for styling
            // Hide message after a few seconds
            setTimeout(() => {
                messageBox.classList.remove('show');
                // Remove type class after hiding to reset for next message
                messageBox.classList.remove(type);
            }, 3000);
        }

        // Function to update the display for Master's BPM gauge
        function updateMasterBpmDisplay() {
            const currentBpm = bpmLevels[masterBpmLevel - 1];
            if (masterBpmDisplay) {
                masterBpmDisplay.textContent = `BPM: ${isBpmStopped ? '‡∏´‡∏¢‡∏∏‡∏î' : currentBpm}`;
            }
            if (masterBpmBar) {
                const percentage = (masterBpmLevel / maxBpmLevel) * 100;
                masterBpmBar.style.width = `${percentage}%`;
            }
            // Emit BPM update to Player via Socket.IO
            if (!isBpmStopped) {
                socket.emit('masterCommand', { type: 'bpm_update', bpm: currentBpm });
            } else {
                socket.emit('masterCommand', { type: 'bpm_stop', message: 'Master: Stop!' }); // Ensure Player knows BPM stopped
            }
        }

        // Function to update the display for Master's arousal (Player's arousal)
        function updateMasterArousalDisplay(arousalLevel) {
            if (masterArousalDisplay) {
                masterArousalDisplay.textContent = `‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏≠‡∏á Player: ${arousalLevel}/10`;
            }
            if (masterArousalBar) {
                const percentage = (arousalLevel / 10) * 100;
                masterArousalBar.style.width = `${percentage}%`;
            }
        }

        // Camera and WebRTC Functions
        async function startCamera(facingMode = 'user') {
            // Stop any existing tracks before getting new stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null; // Clear existing stream from video element
            }
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode },
                    audio: false // Master does not need to send audio
                });
                localVideo.srcObject = localStream;
                localVideo.style.display = 'block'; // Show local video when stream starts
                currentFacingMode = facingMode; // Update current facing mode
                showMessage("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'success');

                // Add or replace tracks in the peer connection
                if (peerConnection) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        if (videoSender) { // If a sender already exists, replace the track
                            await videoSender.replaceTrack(videoTrack);
                            console.log('Replaced video track in peer connection');
                        } else { // First time adding video track to this peer connection
                            videoSender = peerConnection.addTrack(videoTrack, localStream);
                            console.log('Added video track for the first time to peer connection');
                        }
                    }
                }
            } catch (e) {
                console.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ: ", e);
                let errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ";
                if (e.name === "NotAllowedError") {
                    errorMessage += ": ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Ç‡∏≠‡∏á‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå)";
                } else if (e.name === "NotFoundError") {
                    errorMessage += ": ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á";
                } else {
                    errorMessage += `: ${e.message}`;
                }
                showMessage(errorMessage, 'error');
            }
        }

        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                localVideo.style.display = 'none'; // Hide local video when stopped
                showMessage("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'info');
            }
        }

        async function switchCamera() {
            const newFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            await startCamera(newFacingMode);
        }

        // WebRTC Setup: Create Peer Connection
        function createPeerConnection() {
            // Check if peerConnection already exists to prevent re-creation
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                console.warn("Peer connection already exists and is not closed. Skipping creation.");
                return;
            }

            peerConnection = new RTCPeerConnection({
                // Add ICE servers here for STUN/TURN (critical for real-world scenarios)
                // For example:
                // iceServers: [
                //     { urls: 'stun:stun.l.google.com:19302' },
                //     { urls: 'turn:YOUR_TURN_SERVER_URL', username: 'YOUR_USERNAME', credential: 'YOUR_PASSWORD' }
                // ]
            });
            console.log("RTCPeerConnection created.");

            // Add local stream tracks to peer connection if available
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoSender = peerConnection.addTrack(videoTrack, localStream); // Store sender for replaceTrack
                }
            }

            // Event: When an ICE candidate is generated (for NAT traversal)
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate);
                    socket.emit('signal', { candidate: event.candidate });
                }
            };

            // Event: When remote tracks are received from the other peer
            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block'; // Show remote video when stream is received
                    showMessage('‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏à‡∏≤‡∏Å Player ‡πÅ‡∏•‡πâ‡∏ß', 'success');
                    console.log('Received remote stream');
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = (event) => {
                console.log('WebRTC connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    showMessage('‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebRTC ‡∏´‡∏•‡∏∏‡∏î/‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß', 'error');
                    // Potentially trigger a reconnect or return to lobby
                } else if (peerConnection.connectionState === 'connected') {
                    showMessage('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebRTC ‡∏Å‡∏±‡∏ö Player ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!', 'success');
                }
            };

            // Handle signaling state changes
            peerConnection.onsignalingstatechange = (event) => {
                console.log('WebRTC signaling state:', peerConnection.signalingState);
            };
        }

        // Socket.IO Listeners for WebRTC Signaling
        socket.on('paired', async ({ role, room }) => {
            showMessage('‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏°', 'success');
            createPeerConnection(); // Create peer connection when paired

            // Master should initiate the offer
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                socket.emit('signal', { sdp: offer });
                console.log('WebRTC offer sent.');
            } catch (e) {
                console.error("Error creating offer:", e);
                showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏ô‡∏≠ WebRTC", 'error');
            }
        });

        socket.on('signal', async (data) => {
            if (!peerConnection || peerConnection.signalingState === 'closed') {
                createPeerConnection(); // Recreate if closed or not initialized
            }

            if (data.sdp) {
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    if (data.sdp.type === 'answer') {
                        console.log('Received answer from Player');
                    } else if (data.sdp.type === 'offer') {
                        // If Master receives an offer (this can happen if Player initiates)
                        console.log('Received offer from Player, creating answer...');
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        socket.emit('signal', { sdp: answer });
                        console.log('WebRTC answer sent.');
                    }
                } catch (e) {
                    console.error("Error setting remote description or creating answer:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö/‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• WebRTC: " + e.message, 'error');
                }
            } else if (data.candidate) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    console.log('Added ICE candidate');
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ICE candidate: " + e.message, 'error');
                }
            }
        });

        // Handle partner disconnected
        socket.on('partnerDisconnected', (message) => {
            showMessage(message + "\n‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ", 'info');
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                peerConnection.close();
                peerConnection = null;
                videoSender = null; // Clear video sender reference
            }
            stopCamera(); // Ensure local camera is off
            remoteVideo.srcObject = null; // Clear remote video source
            remoteVideo.style.display = 'none'; // Hide remote video
            if (masterElapsedTimeInterval) {
                clearInterval(masterElapsedTimeInterval); // Stop timer
                masterElapsedTimeInterval = null;
            }
            setTimeout(() => {
                window.location.href = '/lobby.html';
            }, 3000); // Redirect after notification
        });


        // --- Event Listeners for DOM elements ---
        document.addEventListener('DOMContentLoaded', () => {
            updateMasterBpmDisplay(); // Initial display update for BPM

            // Start Master's game timer (adjust this to be triggered by game start signal from server)
            let seconds = 0;
            masterElapsedTimeInterval = setInterval(() => {
                seconds++;
                const m = String(Math.floor(seconds / 60)).padStart(2, '0');
                const s = String(seconds % 60).padStart(2, '0');
                masterGameTimer.textContent = `‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: ${m}:${s}`;
            }, 1000);

            // BPM control buttons
            increaseBpmBtn.addEventListener('click', () => {
                if (masterBpmLevel < maxBpmLevel) {
                    masterBpmLevel++;
                    isBpmStopped = false; // Ensure it's not stopped when changing speed
                    updateMasterBpmDisplay();
                } else {
                    showMessage("BPM ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß!", 'info');
                }
            });

            decreaseBpmBtn.addEventListener('click', () => {
                if (masterBpmLevel > 1) {
                    masterBpmLevel--;
                    isBpmStopped = false; // Ensure it's not stopped when changing speed
                    updateMasterBpmDisplay();
                } else {
                    showMessage("BPM ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß!", 'info');
                }
            });

            // Event listener for the Stop/Start BPM button
            stopBpmBtn.addEventListener('click', () => {
                isBpmStopped = !isBpmStopped; // Toggle state
                updateMasterBpmDisplay(); // Update display based on new state
                // Emit command to Player
                if (isBpmStopped) {
                    showMessage('Master ‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î BPM', 'info');
                } else {
                    showMessage('Master ‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏° BPM', 'info');
                }
            });

            // Master's command buttons
            masterOkBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { type: 'ok', message: 'Master: Ok! ‚úÖ‚úÖ‚úÖ' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: Ok!', 'success');
            });
            masterNoBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { type: 'no', message: 'Master: No! ‚ùå‚ùå‚ùå' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: No!', 'success');
            });
            masterCumNowBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { type: 'cum_now', message: 'Master: Cum Now! üí¶üí¶üí¶' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: Cum Now!', 'success');
            });
            masterDontTouchBtn.addEventListener('click', () => {
                socket.emit('masterCommand', { type: 'dont_touch', message: 'Master: Don\'t Touch! üö´üö´üö´' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: Don\'t Touch!', 'success');
            });

            // Camera controls
            masterOpenCameraBtn.addEventListener('click', () => startCamera());
            masterSwapCameraBtn.addEventListener('click', switchCamera);
            masterStopCameraBtn.addEventListener('click', stopCamera);

            // Back to Lobby button
            backToLobbyBtnMaster.addEventListener('click', () => {
                showMessage("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ...", 'info');
                socket.emit('leaveRoom'); // Inform server that Master is leaving the room
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    peerConnection.close();
                    peerConnection = null;
                    videoSender = null; // Clear video sender reference
                }
                stopCamera();
                remoteVideo.srcObject = null;
                remoteVideo.style.display = 'none'; // Ensure remote video is hidden too
                if (masterElapsedTimeInterval) {
                    clearInterval(masterElapsedTimeInterval);
                    masterElapsedTimeInterval = null;
                }
                // Do NOT disconnect the main socket connection here.
                // It should remain connected to join other rooms in the lobby.
                setTimeout(() => {
                    window.location.href = '/lobby.html';
                }, 1500); // Redirect after message
            });
        });

        // Listener for Master to receive Player's arousal updates
        socket.on('playerArousalUpdate', (arousalLevel) => {
            console.log("Master received Player arousal update:", arousalLevel);
            updateMasterArousalDisplay(arousalLevel);
        });

        // Listener for Master side to receive commands from Player
        socket.on('playerCommand', (data) => {
            console.log("Master received command from Player:", data);
            showMessage(`Player: ${data.message}`, 'info'); // Display Player's command as info
        });

        // Handle initial connection or reconnection - server typically sends 'paired'
        socket.on('connect', () => {
            console.log('Master connected to Socket.IO server.');
            // Server should send 'paired' event if game state dictates a live session
        });

        socket.on('disconnect', () => {
            console.log('Master disconnected from Socket.IO server.');
            // This happens if the server restarts or connection is lost.
            // If it's an unexpected disconnect, consider showing a message or attempting to reconnect.
        });
    </script>
</body>
</html>
