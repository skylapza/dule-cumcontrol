<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dule CumControl - Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/game_styles.css"> <!-- Link to external CSS, assuming it exists -->
    <style>
        /* ************************************************* */
        /* Custom styles for player_game.html to emphasize camera */
        /* and center everything */
        /* ************************************************* */

        /* Override body styles for consistent background and centering */
        body {
            font-family: 'Inter', sans-serif; /* Consistent font with other pages */
            background: linear-gradient(135deg, #1a0033, #32004d, #4d0066); /* Consistent gradient */
            color: #e0e0e0; /* Softer white */
            display: flex;
            flex-direction: column; /* Ensure content stacks vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            min-height: 100vh; /* Ensure full viewport height */
            padding: 20px; /* Add padding for overall content */
            margin: 0; /* Remove body margin */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        .game-area-container.player-area {
            max-width: 900px; /* Max width of the Player game area */
            padding: 20px; /* Reduced padding */
            gap: 15px; /* Reduced spacing between elements */
            background: rgba(46, 46, 46, 0.8); /* Consistent background with lobby rooms */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5); /* Deep shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            width: 100%; /* Take full width on smaller screens */
        }

        h1 {
            color: #ffccff;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 204, 255, 0.5);
            margin-bottom: 20px;
        }

        /* Container for all video elements */
        .all-videos-container {
            display: flex;
            flex-direction: column; /* Stacks remote and local+stroke sections */
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between remote video and local video section */
            width: 100%;
            margin-bottom: 1.5rem;
        }

        /* Style for individual video elements to be responsive */
        .video-element {
            width: 100%; /* Each video takes full width of its container */
            max-width: 450px; /* Limit max width for each video */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 16 / 9;
            background-color: #2a3547; /* Darker grey background */
            border-radius: 0.75rem; /* Rounded corners (rounded-lg) */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25); /* Prominent shadow */
            object-fit: cover; /* Cover video area */
            border: 2px solid #60a5fa; /* Blue border */
            display: none; /* Hide video elements by default */
        }

        /* New flex container to hold Local Video and Stroke Visualizer side-by-side */
        .local-video-and-stroke-flex {
            display: flex;
            flex-direction: row; /* Arranges local video and stroke visualizer side-by-side */
            justify-content: center;
            align-items: flex-start; /* Aligns items to the top (video title) */
            gap: 1rem; /* Space between video and stroke visualizer */
            width: 100%; /* Allows it to take up available width within its parent */
            max-width: 500px; /* Max width to control overall size for desktop */
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .local-video-and-stroke-flex {
                flex-direction: column; /* Stack local video and stroke visualizer vertically on small screens */
                align-items: center; /* Center them when stacked */
                gap: 1.5rem; /* More space when stacked */
            }
        }

        /* Common button styles */
        button {
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
            border-radius: 0.75rem; /* Consistent rounded corners */
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        button:hover:enabled {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }

        /* Camera control buttons */
        .camera-controls button {
            padding: 0.6rem 1.2rem; /* Adjusted padding */
            font-size: 0.95rem; /* Adjusted font size */
            border-radius: 0.6rem; /* Adjusted rounded corners */
        }

        /* Timer text */
        #playerGameTimer {
            font-size: 1.2rem; /* Adjusted font size */
            margin-bottom: 1rem;
            color: #b3e0ff; /* Consistent color with lobby */
            font-weight: 600;
        }

        /* Stroke Visualizer */
        @keyframes pulseStroke {
            0% { transform: scaleY(0.7); background-color: #ec4899; } /* Start higher to be more visible */
            50% { transform: scaleY(1.3); background-color: #f472b6; } /* Scale up more noticeably */
            100% { transform: scaleY(0.7); background-color: #ec4899; } /* Return to higher base */
        }
        .stroke-visualizer-container {
            width: 20px; /* Width of the visualizer bar itself */
            min-height: 150px; /* Added: Ensures a default minimum height, even if video is not loaded yet */
            background-color: #ec4899; /* pink-500 */
            border-radius: 0.75rem; /* More rounded */
            display: flex; /* Use flexbox to align inner bar */
            justify-content: center;
            align-items: flex-end; /* Align bar to bottom */
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Add shadow */
        }

        #strokeVisualizer {
            width: 100%;
            height: 60%; /* Changed: Initial height increased to be more visible */
            background-color: #fbcfe8; /* pink-300 */
            transition: height 0.1s ease-out, background-color 0.1s ease-out; /* Smooth transition */
        }
        .stroke-pulse {
            animation: pulseStroke 0.3s ease; /* Applied dynamically */
        }

        /* Arousal display */
        .arousal-display-group {
            margin: 1.5rem auto; /* Consistent margin */
            max-width: 400px; /* Consistent max-width */
            width: 90%; /* Consistent width */
            background: rgba(30, 30, 30, 0.6); /* Consistent background */
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        #playerArousalDisplay {
            font-size: 1.1em; /* Consistent font size */
            font-weight: 700;
            color: #ff5252; /* Consistent red color */
        }
        .arousal-bar-container {
            height: 1.2rem; /* Consistent height */
            margin-top: 0.6rem;
            background-color: #4a4a4a; /* Consistent track color */
            border-radius: 0.6rem;
        }
        #playerArousalBar {
            background-color: #f44336; /* Consistent vibrant red */
        }
        .arousal-buttons button {
            padding: 0.6rem 1rem; /* Consistent padding */
            font-size: 0.9em; /* Consistent font size */
            border-radius: 0.6rem; /* Consistent rounded corners */
            margin: 0.2rem; /* Add small margin for button spacing */
        }
        .arousal-max-label {
            font-size: 0.8rem; /* Consistent font size */
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Player command buttons */
        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem; /* Increased gap */
            margin: 1.5rem auto;
            max-width: 600px; /* Increased max width for more buttons */
        }
        .controls button {
            padding: 0.8rem 1.6rem; /* Consistent button size */
            font-size: 1.1rem; /* Slightly larger text */
            border-radius: 0.75rem;
            min-width: 120px; /* Ensure minimum width for buttons */
        }
        #playerSlowPleaseBtn {
            background-color: #3b82f6; /* Blue */
        }
        #playerICanCumBtn {
            background-color: #22c55e; /* Green */
        }
        #playerPleaseStopBtn {
            background-color: #f97316; /* Orange */
        }

        /* Notification area (consistent with lobby and master_control) */
        #messageBox {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.3); /* Reddish for error */
            border-radius: 8px;
            color: white;
            font-size: 1em;
            max-width: 400px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 1000; /* Ensure it's on top */
            position: fixed; /* Fixed position */
            top: 20px; /* From top */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust for perfect centering */
        }
        #messageBox.show {
            opacity: 1;
            visibility: visible;
        }
        #messageBox.success {
            background-color: rgba(0, 128, 0, 0.3); /* Greenish for success */
        }
        #messageBox.info {
            background-color: rgba(0, 100, 200, 0.3); /* Bluish for info */
        }

        /* Back to Lobby button */
        #backToLobbyBtnPlayer {
            background-color: #4a5568; /* Darker gray for subtle look */
            color: #cbd5e0;
            border-bottom: 1px solid #718096; /* Subtle underline effect */
            text-decoration: none; /* Remove default underline */
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            margin-top: 2rem;
        }
        #backToLobbyBtnPlayer:hover {
            background-color: #2d3748;
            color: #edf2f7;
            text-decoration: none;
        }

        /* Headings above videos */
        .video-label-container { /* New container for video titles */
            text-align: center;
            margin-bottom: 0.5rem;
            color: #b3e0ff; /* Light blue for video titles */
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="messageBox" class="message-box"></div>

    <div class="max-w-2xl game-area-container player-area">
        <h1 class="text-3xl font-bold text-center mb-4">Player</h1>

        <p id="playerGameTimer" class="text-lg">‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: 00:00</p>

        <div class="flex justify-center gap-4 my-4 camera-controls">
            <button id="playerOpenCameraBtn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button id="playerSwapCameraBtn" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded">‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button id="playerStopCameraBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
        </div>

        <div class="all-videos-container">
            <!-- Remote Video (Master's camera) -->
            <div>
                <h3 class="video-label-container">‡∏Å‡∏•‡πâ‡∏≠‡∏á Master</h3>
                <video id="remoteVideo" class="video-element" autoplay playsinline></video>
            </div>

            <!-- Local Video (Your camera) and Stroke Visualizer side-by-side -->
            <div class="local-video-and-stroke-flex">
                <div>
                    <h3 class="video-label-container">‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</h3>
                    <video id="localVideo" class="video-element" autoplay playsinline muted></video>
                </div>
                <div class="stroke-visualizer-container">
                    <div id="strokeVisualizer" style="height: 60%"></div> <!-- Changed initial height here -->
                </div>
            </div>
        </div>

        <div class="text-center mb-6 arousal-display-group">
            <div id="playerArousalDisplay" class="text-lg font-bold">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: 5/10</div>
            <div class="w-full bg-gray-600 h-5 rounded relative overflow-hidden my-2 arousal-bar-container">
                <div id="playerArousalBar" class="bg-red-500 h-full transition-all duration-300" style="width: 50%"></div>
                <span class="absolute right-2 top-1/2 -translate-y-1/2 text-xs arousal-max-label">CUM</span>
            </div>
            <div class="flex justify-center gap-4 arousal-buttons">
                <button id="decreaseArousalBtn" class="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded">‡∏•‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö</button>
                <button id="increaseArousalBtn" class="bg-green-500 hover:bg-green-600 px-4 py-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏î‡∏±‡∏ö</button>
            </div>
        </div>

        <div class="flex justify-center gap-4 mb-4 controls">
            <button id="playerSlowPleaseBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">slow please</button>
            <button id="playerICanCumBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded">I can cum</button>
            <button id="playerPleaseStopBtn" class="bg-orange-500 hover:bg-orange-600 px-4 py-2 rounded">please stop</button>
        </div>

        <div class="text-center mt-8">
            <button id="backToLobbyBtnPlayer" class="underline text-sm">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Global socket connection
        const socket = io();

        // WebRTC related variables
        let peerConnection;
        let localStream;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let videoSender = null; // To store the RTCRtpSender for the video track for replaceTrack

        // NEW: WebRTC Config with STUN servers
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
                // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° TURN servers ‡πÑ‡∏î‡πâ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ú‡πà‡∏≤‡∏ô NAT ‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏°‡∏≤‡∏Å
            ]
        };

        // Player Game Logic variables
        const maxArousal = 10;
        let playerArousalLevel = 5;
        let playerGameElapsedTime = 0;
        let playerElapsedTimeInterval = null; // Interval ID for game timer
        let strokeInterval; // For BPM animation

        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const playerGameTimer = document.getElementById('playerGameTimer');
        const playerArousalDisplay = document.getElementById('playerArousalDisplay');
        const playerArousalBar = document.getElementById('playerArousalBar');
        const increaseArousalBtn = document.getElementById('increaseArousalBtn');
        const decreaseArousalBtn = document.getElementById('decreaseArousalBtn');
        const playerSlowPleaseBtn = document.getElementById('playerSlowPleaseBtn');
        const playerICanCumBtn = document.getElementById('playerICanCumBtn');
        const playerPleaseStopBtn = document.getElementById('playerPleaseStopBtn');
        const backToLobbyBtnPlayer = document.getElementById('backToLobbyBtnPlayer');
        const playerOpenCameraBtn = document.getElementById('playerOpenCameraBtn');
        const playerSwapCameraBtn = document.getElementById('playerSwapCameraBtn');
        const playerStopCameraBtn = document.getElementById('playerStopCameraBtn');
        const strokeVisualizer = document.getElementById('strokeVisualizer');
        const strokeVisualizerContainer = document.querySelector('.stroke-visualizer-container'); // Get the container
        const messageBox = document.getElementById('messageBox'); // For custom notifications


        // Function to play stroke sound (Tone.js could be used for more control)
        function playStrokeSound() {
            // Note: For actual deployment, you'll need to host 'stroke.mp3' or use an audio library like Tone.js
            // For now, using standard Audio object. Browser auto-play policies might block this without user interaction.
            try {
                const audio = new Audio('/sounds/stroke.mp3');
                audio.volume = 0.3;
                audio.play().catch(e => console.warn("Cannot play audio: ", e));
            } catch (e) {
                console.error("Error creating audio object:", e);
            }
        }

        // Function to display custom messages (consistent with other pages)
        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = 'message-box show'; // Reset classes and show
            messageBox.classList.add(type); // Add specific type class for styling
            // Hide message after a few seconds
            setTimeout(() => {
                messageBox.classList.remove('show');
                // Remove type class after hiding to reset for next message
            }, 3000);
        }

        // Function to update arousal display
        function updateArousalDisplay() {
            playerArousalDisplay.textContent = `‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: ${playerArousalLevel}/${maxArousal}`;
            playerArousalBar.style.width = `${(playerArousalLevel / maxArousal) * 100}%`;
            socket.emit("playerArousalUpdate", playerArousalLevel); // Emit to Master via Socket.IO
        }

        // NEW: Function to synchronize stroke visualizer height with local video
        function syncStrokeVisualizerHeight() {
            if (localVideo && strokeVisualizerContainer && localVideo.style.display !== 'none') {
                // Wait for the video to potentially render and get its actual height
                requestAnimationFrame(() => {
                    const videoHeight = localVideo.offsetHeight;
                    if (videoHeight > 0) { // Ensure video has a height
                        strokeVisualizerContainer.style.height = `${videoHeight}px`;
                    }
                });
            } else {
                 // Fallback height if video is hidden or not loaded
                 // This ensures the container is visible from the start
                 strokeVisualizerContainer.style.height = `200px`;
            }
        }

        // Function to animate the stroke visualizer
        function animateStrokeVisualizer(bpm) {
            if (strokeInterval) clearInterval(strokeInterval); // Clear previous interval

            if (bpm === 0) { // If BPM is 0, stop animation and reset visualizer
                strokeVisualizer.style.height = '0%';
                strokeVisualizer.classList.remove('stroke-pulse'); // Ensure animation class is removed
                return;
            }

            const intervalMs = 60000 / bpm; // Time for one beat in milliseconds

            strokeInterval = setInterval(() => {
                // "Up" stroke
                strokeVisualizer.style.height = '100%';
                strokeVisualizer.classList.add('stroke-pulse'); // Add pulse animation
                if (bpm >= 140) playStrokeSound(); // Play sound only for higher BPM

                setTimeout(() => {
                    // "Down" stroke
                    strokeVisualizer.style.height = '60%'; // Return to the new default visible height
                    // Remove class after the animation cycle completes to allow it to re-trigger
                    setTimeout(() => {
                        strokeVisualizer.classList.remove('stroke-pulse');
                    }, 300); // Should match or be slightly longer than pulseStroke animation duration
                }, intervalMs / 2); // Half the interval for down stroke
            }, intervalMs);
        }

        // Camera and WebRTC Functions
        async function startCamera(facingMode = 'user') {
            // Stop any existing tracks before getting new stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null; // Clear existing stream from video element
            }
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode },
                    audio: false // Player does not need to send audio
                });
                localVideo.srcObject = localStream;
                localVideo.style.display = 'block'; // Show local video when stream starts
                currentFacingMode = facingMode; // Update current facing mode
                showMessage("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'success');

                // Call sync height after video is displayed and has a chance to render
                localVideo.onloadedmetadata = () => {
                    syncStrokeVisualizerHeight();
                };
                if (localVideo.readyState >= 2) { // If video is already loaded
                    syncStrokeVisualizerHeight();
                }


                // Add or replace tracks in the peer connection
                if (peerConnection) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        if (videoSender) { // If a sender already exists, replace the track
                            await videoSender.replaceTrack(videoTrack);
                            console.log('Replaced video track in peer connection');
                        } else { // First time adding video track to this peer connection
                            videoSender = peerConnection.addTrack(videoTrack, localStream);
                            console.log('Added video track for the first time to peer connection');
                        }
                    }
                }
            } catch (e) {
                console.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ: ", e);
                let errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ";
                if (e.name === "NotAllowedError") {
                    errorMessage += ": ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Ç‡∏≠‡∏á‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå)";
                } else if (e.name === "NotFoundError") {
                    errorMessage += ": ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á";
                } else {
                    errorMessage += `: ${e.message}`;
                }
                showMessage(errorMessage, 'error');
            }
        }

        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                localVideo.style.display = 'none'; // Hide local video when stopped
                showMessage("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'info');
            }
            syncStrokeVisualizerHeight(); // Reset height when camera stops
        }

        async function switchCamera() {
            const newFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            await startCamera(newFacingMode);
        }

        // WebRTC Setup: Create Peer Connection
        function createPeerConnection() {
            // Check if peerConnection already exists to prevent re-creation
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                console.warn("Peer connection already exists and is not closed. Skipping creation.");
                return;
            }

            peerConnection = new RTCPeerConnection(rtcConfig); // <--- Updated to use rtcConfig
            console.log("RTCPeerConnection created.");

            // Add local stream tracks to peer connection if available
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoSender = peerConnection.addTrack(videoTrack, localStream); // Store sender for replaceTrack
                }
            }

            // Event: When an ICE candidate is generated (for NAT traversal)
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate);
                    socket.emit('signal', { candidate: event.candidate });
                }
            };

            // Event: When remote tracks are received from the other peer
            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block'; // Show remote video when stream is received
                    showMessage('‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏à‡∏≤‡∏Å Master ‡πÅ‡∏•‡πâ‡∏ß', 'success');
                    console.log('Received remote stream');
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = (event) => {
                console.log('WebRTC connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    showMessage('‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebRTC ‡∏´‡∏•‡∏∏‡∏î/‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß', 'error');
                    // Potentially trigger a reconnect or return to lobby
                } else if (peerConnection.connectionState === 'connected') {
                    showMessage('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebRTC ‡∏Å‡∏±‡∏ö Master ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!', 'success');
                }
            };

            // Handle signaling state changes
            peerConnection.onsignalingstatechange = (event) => {
                console.log('WebRTC signaling state:', peerConnection.signalingState);
            };
        }

        // Socket.IO Listeners for WebRTC Signaling
        socket.on('paired', async ({ role, room }) => {
            showMessage('‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏°', 'success');
            createPeerConnection(); // Create peer connection when paired

            // Player waits for offer from Master, then sends answer.
            // If the Master is slow or disconnected, the Player might need to handle
            // timeouts or re-pairing.
        });

        socket.on('signal', async (data) => {
            if (!peerConnection || peerConnection.signalingState === 'closed') {
                createPeerConnection(); // Recreate if closed or not initialized
            }

            if (data.sdp) {
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    if (data.sdp.type === 'offer') {
                        // If Player receives an offer (as expected from Master)
                        console.log('Received offer from Master, creating answer...');
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        socket.emit('signal', { sdp: answer });
                        console.log('WebRTC answer sent.');
                    } else if (data.sdp.type === 'answer') {
                        console.log('Received answer from Master (unexpected for Player, but handled)');
                    }
                } catch (e) {
                    console.error("Error setting remote description or creating answer:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö/‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• WebRTC: " + e.message, 'error');
                }
            } else if (data.candidate) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    console.log('Added ICE candidate');
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                    showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ICE candidate: " + e.message, 'error');
                }
            }
        });

        // Handle partner disconnected
        socket.on('partnerDisconnected', (message) => {
            showMessage(message + "\n‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ", 'info');
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                peerConnection.close();
                peerConnection = null;
                videoSender = null; // Clear video sender reference
            }
            stopCamera(); // Ensure local camera is off, which also calls syncStrokeVisualizerHeight
            remoteVideo.srcObject = null; // Clear remote video source
            remoteVideo.style.display = 'none'; // Hide remote video
            if (playerElapsedTimeInterval) {
                clearInterval(playerElapsedTimeInterval); // Stop timer
                playerElapsedTimeInterval = null;
            }
            if (strokeInterval) {
                clearInterval(strokeInterval); // Stop stroke animation
                strokeInterval = null;
                strokeVisualizer.style.height = '0%'; // Reset visualizer
                strokeVisualizer.classList.remove('stroke-pulse');
            }
            setTimeout(() => {
                window.location.href = '/lobby.html';
            }, 3000); // Redirect after notification
        });


        // --- Event Listeners for DOM elements ---
        document.addEventListener('DOMContentLoaded', () => {
            updateArousalDisplay(); // Initial display update for arousal
            syncStrokeVisualizerHeight(); // Call initially in case video is somehow already loaded/visible

            // Start Player's game timer (adjust this to be triggered by game start signal from server)
            let seconds = 0;
            playerElapsedTimeInterval = setInterval(() => {
                seconds++;
                const m = String(Math.floor(seconds / 60)).padStart(2, '0');
                const s = String(seconds % 60).padStart(2, '0');
                playerGameTimer.textContent = `‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: ${m}:${s}`;
            }, 1000);

            // Arousal buttons
            increaseArousalBtn.addEventListener('click', () => {
                if (playerArousalLevel < maxArousal) {
                    playerArousalLevel++;
                    updateArousalDisplay();
                    showMessage("‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô", 'info');
                } else {
                    showMessage("‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏ñ‡∏∂‡∏á‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß!", 'info');
                }
            });

            decreaseArousalBtn.addEventListener('click', () => {
                if (playerArousalLevel > 1) { // Assuming minimum arousal is 1
                    playerArousalLevel--;
                    updateArousalDisplay();
                    showMessage("‡∏•‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô", 'info');
                } else {
                    showMessage("‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏ñ‡∏∂‡∏á‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß!", 'info');
                }
            });

            // Camera controls
            playerOpenCameraBtn.addEventListener('click', () => startCamera());
            playerSwapCameraBtn.addEventListener('click', switchCamera);
            playerStopCameraBtn.addEventListener('click', stopCamera);

            // Player's request buttons
            playerSlowPleaseBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { type: 'slow_please', message: 'Player: slow please' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠: Slow Please!', 'success');
            });
            playerICanCumBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { type: 'i_can_cum', message: 'Player: I can cum' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠: I Can Cum!', 'success');
            });
            playerPleaseStopBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { type: 'please_stop', message: 'Player: please stop' });
                showMessage('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠: Please Stop!', 'success');
            });

            // Back to Lobby button
            backToLobbyBtnPlayer.addEventListener('click', () => {
                showMessage("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ...", 'info');
                socket.emit('leaveRoom'); // Inform server that Player is leaving the room
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    peerConnection.close();
                    peerConnection = null;
                    videoSender = null; // Clear video sender reference
                }
                stopCamera(); // Also calls syncStrokeVisualizerHeight
                remoteVideo.srcObject = null;
                remoteVideo.style.display = 'none'; // Ensure remote video is hidden too
                if (playerElapsedTimeInterval) {
                    clearInterval(playerElapsedTimeInterval);
                    playerElapsedTimeInterval = null;
                }
                if (strokeInterval) {
                    clearInterval(strokeInterval);
                    strokeInterval = null;
                    strokeVisualizer.style.height = '0%'; // Reset visualizer
                    strokeVisualizer.classList.remove('stroke-pulse');
                }
                // Do NOT disconnect the main socket connection here.
                // It should remain connected to join other rooms in the lobby.
                setTimeout(() => {
                    window.location.href = '/lobby.html';
                }, 1500); // Redirect after message
            });

            // Add event listener for window resize to resync visualizer height
            window.addEventListener('resize', syncStrokeVisualizerHeight);
        });

        // Socket.IO Listeners for game commands from Master
        socket.on('masterCommand', (data) => {
            console.log("Player received command from Master:", data);
            if (data.type === 'cum_now') {
                showMessage("Master ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏´‡∏•‡∏±‡πà‡∏á! üí¶üí¶üí¶", 'success');
                playerArousalLevel = maxArousal; // Set arousal to max
                updateArousalDisplay();
                // Consider adding game end logic here
            } else if (data.type === 'dont_touch') {
                showMessage(data.message, 'error'); // Usually a warning/error
            } else if (data.type === 'ok' || data.type === 'no') {
                showMessage(data.message, 'info'); // General info
            } else if (data.type === 'bpm_update') {
                animateStrokeVisualizer(data.bpm);
                showMessage(`‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß: ${data.bpm} BPM`, 'info');
            } else if (data.type === 'bpm_stop') {
                animateStrokeVisualizer(0); // Stop animation by setting BPM to 0
                showMessage("Master ‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î!", 'info');
            } else if (data.type === 'bpm_start') {
                animateStrokeVisualizer(data.bpm); // Re-start with current BPM
                showMessage("Master ‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°!", 'info');
            }
        });

        // Handle initial connection or reconnection - server typically sends 'paired'
        socket.on('connect', () => {
            console.log('Player connected to Socket.IO server.');
            // Server should send 'paired' event if game state dictates a live session
        });

        socket.on('disconnect', () => {
            console.log('Player disconnected from Socket.IO server.');
            // This happens if the server restarts or connection is lost.
            // If it's an unexpected disconnect, consider showing a message or attempting to reconnect.
        });
    </script>
</body>
</html>

