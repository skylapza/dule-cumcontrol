<!-- public/player_game.html -->
<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dule CumControl - Player</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="/game_styles.css"> <!-- ‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÑ‡∏õ‡∏ó‡∏µ‡πà CSS ‡∏ó‡∏µ‡πà‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ -->
  <style>
    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡πà‡∏ô Stroke Visualizer ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ */
    @keyframes pulseStroke {
      0% { transform: scaleY(1); }
      50% { transform: scaleY(1.3); background-color: #f472b6; } /* ‡∏™‡∏µ‡∏ä‡∏°‡∏û‡∏π‡∏≠‡∏°‡πÅ‡∏î‡∏á */
      100% { transform: scaleY(1); }
    }
    .stroke-pulse {
      animation: pulseStroke 0.3s ease;
    }

    /* ************************************************* */
    /* ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏™‡πÑ‡∏ï‡∏•‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö player_game.html ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á */
    /* ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á */
    /* ************************************************* */

    /* Override body styles from game_styles.css to center content */
    body {
      display: flex;
      flex-direction: column; /* Ensure content stacks vertically */
      justify-content: center; /* Center vertically */
      align-items: center; /* Center horizontally */
      min-height: 100vh; /* Ensure full viewport height */
      padding: 0; /* Remove body padding to allow full flex control */
      margin: 0; /* Remove body margin */
    }

    .game-area-container.player-area {
        max-width: 900px; /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏° Player */
        padding: 20px; /* ‡∏•‡∏î padding ‡∏•‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ */
        gap: 15px; /* ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏≠‡∏á‡∏Ñ‡πå‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö */
        /* ‡∏•‡∏ö flex-grow: 1; ‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ó‡∏ô‡πÄ‡∏ô‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô */
        /* ‡∏•‡∏ö mx-auto ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å HTML ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ align-items: center ‡∏Ç‡∏≠‡∏á body ‡πÅ‡∏ó‡∏ô */
    }

    /* Style for the video elements to be responsive and larger */
    .video-display-area { /* Container for local and remote videos */
        display: flex;
        flex-direction: column; /* ‡∏à‡∏±‡∏î‡∏ß‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏ö‡∏ö ‡∏ö‡∏ô-‡∏•‡πà‡∏≤‡∏á */
        /* flex-wrap: wrap; ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö column */
        justify-content: center; /* ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ */
        align-items: center; /* ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô */
        gap: 1rem; /* ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô */
        width: 100%; /* ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà */
        margin-bottom: 1rem;
    }

    .video-element {
        width: 100%; /* ‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á video-display-area */
        max-width: 450px; /* ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß */
        height: auto; /* ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô */
        aspect-ratio: 16 / 9;
        background-color: #2a3547; /* ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤‡πÄ‡∏Ç‡πâ‡∏°‡∏Ç‡∏∂‡πâ‡∏ô */
        border-radius: 0.75rem; /* ‡∏°‡∏∏‡∏°‡πÇ‡∏Ñ‡πâ‡∏á‡∏°‡∏ô (rounded-lg) */
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25); /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏≤‡πÉ‡∏´‡πâ‡πÇ‡∏î‡∏î‡πÄ‡∏î‡πà‡∏ô */
        object-fit: cover; /* ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ */
        border: 2px solid #60a5fa; /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≠‡∏ö‡∏™‡∏µ‡∏ü‡πâ‡∏≤ */
        display: none; /* <<--- IMPORTANT: Hide video elements by default */
    }

    /* Responsive adjustments for videos */
    @media (max-width: 767px) {
        .video-display-area {
            flex-direction: column; /* ‡∏ß‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å */
            align-items: center;
            gap: 1rem;
        }
        .video-element {
            width: 100%; /* ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏á video-display-area */
            max-width: 450px; /* ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ */
        }
    }

    /* Smaller camera control buttons */
    .camera-controls button {
        padding: 0.4rem 0.8rem; /* ‡∏•‡∏î padding */
        font-size: 0.9rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
        border-radius: 0.5rem; /* ‡∏õ‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏°‡πÇ‡∏Ñ‡πâ‡∏á‡∏°‡∏ô */
    }

    /* Smaller timer text */
    #playerGameTimer {
        font-size: 1.1rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
        margin-bottom: 0.5rem;
    }

    /* Smaller stroke visualizer */
    .stroke-visualizer-container {
      width: 15px; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á */
      height: 150px; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á */
      background-color: #ec4899; /* pink-500 */
      border-radius: 0.5rem;
      justify-content: flex-end;
      overflow: hidden;
      position: relative;
      margin-left: 0.5rem; /* ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ ‡πÉ‡∏´‡πâ‡∏ä‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô */
    }

    #strokeVisualizer {
      width: 100%;
      background-color: #fbcfe8; /* pink-300 */
      transition: height 0.1s ease-out;
    }

    /* Smaller arousal display */
    .arousal-display-group {
        margin-top: 0.5rem; /* ‡∏•‡∏î margin-top ‡πÉ‡∏´‡πâ‡∏ä‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô */
        max-width: 350px; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î */
        width: 100%; /* ‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á parent ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô */
    }
    #playerArousalDisplay {
        font-size: 1rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
    }
    .arousal-bar-container {
        height: 1rem; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á bar */
        margin-top: 0.4rem;
    }
    .arousal-buttons button {
        padding: 0.4rem 0.8rem; /* ‡∏•‡∏î padding */
        font-size: 0.9rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
    }
    .arousal-max-label {
        font-size: 0.7rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
    }

    /* Smaller control buttons */
    .controls button {
        padding: 0.6rem 1.2rem; /* ‡∏•‡∏î padding */
        font-size: 1rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
        margin: 0.4rem; /* ‡∏•‡∏î margin */
    }

    /* Smaller back to lobby button */
    #backToLobbyBtnPlayer {
        padding: 0.3rem 0.7rem; /* ‡∏•‡∏î padding */
        font-size: 0.8rem; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ */
        margin-top: 1rem; /* ‡∏•‡∏î margin-top */
    }

    /* Notification area adjustments */
    .player-notification {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        margin-top: 0.5rem;
        margin: 0 auto; /* ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô */
    }
    
    /* Headings above videos */
    .video-display-area h3 {
        text-align: center; /* ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° */
        margin-bottom: 0.5rem; /* ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ */
    }

    /* Flex container for camera and stroke visualizer */
    /* Adjust this to ensure the stroke visualizer aligns correctly next to the stacked videos */
    .player-visual-area-flex {
        display: flex;
        flex-direction: row; /* ‡∏à‡∏±‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏•‡∏∞ stroke bar ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≤‡∏á‡∏Å‡∏±‡∏ô */
        justify-content: center;
        align-items: flex-start; /* ‡∏à‡∏±‡∏î‡πÉ‡∏´‡πâ stroke bar ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ö‡∏ô‡∏™‡∏∏‡∏î */
        width: 100%;
        margin-bottom: 1.5rem;
    }

  </style>
</head>
<body class="bg-gray-900 text-white font-sans">
  <div class="max-w-2xl game-area-container player-area"> <!-- Removed mx-auto here -->
    <h1 class="text-3xl font-bold text-center mb-4">Player</h1>

    <p id="playerGameTimer" class="text-lg">‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: 00:00</p>

    <div class="flex justify-center gap-2 my-2 camera-controls">
      <button id="playerOpenCameraBtn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
      <button id="playerSwapCameraBtn" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded">‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
      <button id="playerStopCameraBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
    </div>
    
    <div class="player-visual-area-flex">
        <!-- Videos are now stacked vertically within this area -->
        <div class="video-display-area">
            <div>
                <h3>‡∏Å‡∏•‡πâ‡∏≠‡∏á Master</h3>
                <video id="remoteVideo" class="video-element" autoplay playsinline></video>
            </div>
            <div>
                <h3>‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</h3>
                <video id="localVideo" class="video-element" autoplay playsinline muted></video>
            </div>
        </div>
        
        <div class="stroke-visualizer-container">
          <div id="strokeVisualizer" style="height: 30%"></div>
        </div>
    </div>
    <div id="playerNotification" class="player-notification"></div> <!-- Notification area -->

    <div class="text-center mb-6 arousal-display-group">
      <div id="playerArousalDisplay" class="text-lg font-bold">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: 5/10</div>
      <div class="w-full bg-gray-600 h-5 rounded relative overflow-hidden my-2 arousal-bar-container">
        <div id="playerArousalBar" class="bg-red-500 h-full transition-all duration-300" style="width: 50%"></div>
        <span class="absolute right-2 top-1/2 -translate-y-1/2 text-xs arousal-max-label">CUM</span>
      </div>
      <div class="flex justify-center gap-4 arousal-buttons">
        <button id="decreaseArousalBtn" class="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded">‡∏•‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö</button>
        <button id="increaseArousalBtn" class="bg-green-500 hover:bg-green-600 px-4 py-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏î‡∏±‡∏ö</button>
      </div>
    </div>

    <div class="flex justify-center gap-4 mb-4 controls">
      <button id="playerSlowPleaseBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">slow please</button>
      <button id="playerICanCumBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded">I can cum</button>
      <button id="playerPleaseStopBtn" class="bg-orange-500 hover:bg-orange-600 px-4 py-2 rounded">please stop</button>
    </div>

    <div class="text-center mt-8">
      <button id="backToLobbyBtnPlayer" class="underline text-sm bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ</button>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <!-- Removed: <script src="/script.js"></script> as WebRTC logic is now in this file -->

  <script>
    // Global socket connection
    const socket = io();

    // WebRTC related variables
    let peerConnection;
    let localStream;
    let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera

    // Player Game Logic variables
    const maxArousal = 10;
    let playerArousalLevel = 5;
    let playerGameElapsedTime = 0;
    let playerElapsedTimeInterval = null;
    let strokeInterval; // For BPM animation

    // DOM Elements
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const playerGameTimer = document.getElementById('playerGameTimer');
    const playerNotification = document.getElementById('playerNotification');
    const playerArousalDisplay = document.getElementById('playerArousalDisplay');
    const playerArousalBar = document.getElementById('playerArousalBar');
    const increaseArousalBtn = document.getElementById('increaseArousalBtn');
    const decreaseArousalBtn = document.getElementById('decreaseArousalBtn');
    const playerSlowPleaseBtn = document.getElementById('playerSlowPleaseBtn');
    const playerICanCumBtn = document.getElementById('playerICanCumBtn');
    const playerPleaseStopBtn = document.getElementById('playerPleaseStopBtn');
    const backToLobbyBtnPlayer = document.getElementById('backToLobbyBtnPlayer');
    const playerOpenCameraBtn = document.getElementById('playerOpenCameraBtn');
    const playerSwapCameraBtn = document.getElementById('playerSwapCameraBtn');
    const playerStopCameraBtn = document.getElementById('playerStopCameraBtn');
    const strokeVisualizer = document.getElementById('strokeVisualizer');


    // Function to play stroke sound
    function playStrokeSound() {
      const audio = new Audio('/sounds/stroke.mp3');
      audio.volume = 0.3;
      audio.play().catch(e => console.warn("‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏±‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥:", e));
    }

    // Function to show notifications
    function showPlayerNotification(message, isError = false) {
        if (playerNotification) {
            playerNotification.textContent = message;
            playerNotification.className = 'player-notification ' + (isError ? 'error' : ''); // Reset classes
            playerNotification.classList.add('show');
            setTimeout(() => {
                playerNotification.classList.remove('show');
            }, 3000);
        }
    }

    // Function to update arousal display
    function updateArousalDisplay() {
      playerArousalDisplay.textContent = `‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏á‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: ${playerArousalLevel}/${maxArousal}`;
      playerArousalBar.style.width = `${(playerArousalLevel / maxArousal) * 100}%`;
      socket.emit("playerArousalUpdate", playerArousalLevel); // Emit to Master via Socket.IO
    }

    // Function to animate the stroke visualizer
    function animateStrokeVisualizer(bpm) {
      if (strokeInterval) clearInterval(strokeInterval); // Clear previous interval

      if (bpm === 0) { // If BPM is 0, stop animation and reset visualizer
          strokeVisualizer.style.height = '0%';
          return;
      }

      const intervalMs = 60000 / bpm; // Time for one beat in milliseconds
      
      strokeInterval = setInterval(() => {
        // "Up" stroke
        strokeVisualizer.style.height = '100%';
        strokeVisualizer.classList.add('stroke-pulse'); // Add pulse animation
        if (bpm >= 140) playStrokeSound(); // Play sound only for higher BPM

        setTimeout(() => {
          // "Down" stroke
          strokeVisualizer.style.height = '30%';
          strokeVisualizer.classList.remove('stroke-pulse'); // Remove pulse animation
        }, intervalMs / 2); // Half the interval for down stroke
      }, intervalMs);
    }

    // Camera and WebRTC Functions
    async function startCamera(facingMode = 'user') {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: facingMode },
          audio: false
        });
        localVideo.srcObject = localStream;
        localVideo.style.display = 'block'; // Show local video when stream starts
        currentFacingMode = facingMode; // Update current facing mode

        // Add tracks to peer connection if it exists
        if (peerConnection) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }

      } catch (e) {
        console.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ: ", e);
        showPlayerNotification("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ: " + e.message, true);
      }
    }

    function stopCamera() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        localVideo.srcObject = null;
        localVideo.style.display = 'none'; // Hide local video when stopped
      }
    }

    async function switchCamera() {
      const newFacingMode = (currentFacingMode === 'user' || currentFacingMode === undefined) ? 'environment' : 'user';
      await startCamera(newFacingMode);
    }

    // WebRTC Setup
    function createPeerConnection() {
        peerConnection = new RTCPeerConnection();

        // Add local stream tracks to peer connection
        if (localStream) {
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        }

        // Event: When an ICE candidate is generated
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', { candidate: event.candidate });
            }
        };

        // Event: When remote tracks are received
        peerConnection.ontrack = (event) => {
            if (remoteVideo.srcObject !== event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                remoteVideo.style.display = 'block'; // Show remote video when stream is received
                console.log('Received remote stream');
            }
        };
    }

    // Socket.IO Listeners for WebRTC Signaling
    socket.on('paired', async ({ role, room }) => {
        showPlayerNotification('‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏°');
        createPeerConnection(); // Create peer connection when paired

        // If this player is the 'initiator' (e.g., the first one to establish the connection or 'master' usually)
        // In our setup, server redirects to specific HTML, so roles are clear.
        // Player will create an Answer if Master creates an Offer.
        // But for initial connection, either can initiate if needed. Let's make Master the initiator.
        // Player simply waits for offer, then sends answer.
    });

    socket.on('signal', async (data) => {
        if (!peerConnection) {
            createPeerConnection();
        }

        if (data.sdp) {
            // Received an offer or answer
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

            if (data.sdp.type === 'offer') {
                // If it's an offer, create an answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit('signal', { sdp: answer });
            }
        } else if (data.candidate) {
            // Received an ICE candidate
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    });

    // Handle partner disconnected
    socket.on('partnerDisconnected', (message) => {
        showPlayerNotification(message + "\n‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡πá‡∏≠‡∏ö‡∏ö‡∏µ‡πâ", true);
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        stopCamera(); // Ensure local camera is off
        remoteVideo.style.display = 'none'; // Hide remote video
        if (strokeInterval) clearInterval(strokeInterval); // Stop stroke animation
        setTimeout(() => {
            window.location.href = '/lobby.html';
        }, 3000); // Redirect after notification
    });


    // --- Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        updateArousalDisplay(); // Initial display update

        // Arousal buttons
        if (increaseArousalBtn) {
          increaseArousalBtn.addEventListener('click', () => {
            if (playerArousalLevel < maxArousal) {
              playerArousalLevel++;
              updateArousalDisplay();
            }
          });
        }
        if (decreaseArousalBtn) {
          decreaseArousalBtn.addEventListener('click', () => {
            if (playerArousalLevel > 1) { // Assuming minimum arousal is 1
              playerArousalLevel--;
              updateArousalDisplay();
            }
          });
        }

        // Camera controls
        playerOpenCameraBtn.addEventListener('click', () => startCamera());
        playerSwapCameraBtn.addEventListener('click', switchCamera);
        playerStopCameraBtn.addEventListener('click', stopCamera);

        // Player's request buttons
        playerSlowPleaseBtn.addEventListener('click', () => {
            socket.emit('playerCommand', { type: 'slow_please', message: 'Player: slow please' });
        });
        playerICanCumBtn.addEventListener('click', () => {
            socket.emit('playerCommand', { type: 'i_can_cum', message: 'Player: I can cum' });
        });
        playerPleaseStopBtn.addEventListener('click', () => {
            socket.emit('playerCommand', { type: 'please_stop', message: 'Player: please stop' });
        });

        // Back to Lobby button
        if (backToLobbyBtnPlayer) {
            backToLobbyBtnPlayer.addEventListener('click', () => {
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                stopCamera();
                remoteVideo.style.display = 'none'; // Ensure remote video is hidden too
                if (strokeInterval) clearInterval(strokeInterval);
                socket.disconnect(); // Inform server about disconnect
                window.location.href = '/lobby.html';
            });
        }

        // Timer
        let seconds = 0;
        setInterval(() => {
          seconds++;
          const m = String(Math.floor(seconds / 60)).padStart(2, '0');
          const s = String(seconds % 60).padStart(2, '0');
          playerGameTimer.textContent = `‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô: ${m}:${s}`;
        }, 1000);
    });

    // Socket.IO Listeners for game commands from Master
    socket.on('masterCommand', (data) => {
        console.log("Player received command from Master:", data);
        if (data.type === 'cum_now') {
            showPlayerNotification("Master ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏´‡∏•‡∏±‡πà‡∏á! üí¶üí¶üí¶");
            playerArousalLevel = maxArousal;
            updateArousalDisplay();
        } else if (data.type === 'dont_touch') {
            showPlayerNotification(data.message);
        } else if (data.type === 'ok' || data.type === 'no') {
            showPlayerNotification(data.message);
        } else if (data.type === 'bpm_update') {
            animateStrokeVisualizer(data.bpm);
            showPlayerNotification(`‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß: ${data.bpm} BPM`);
        } else if (data.type === 'bpm_stop') {
            animateStrokeVisualizer(0); // Stop animation by setting BPM to 0
            showPlayerNotification("Master ‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î!");
        } else if (data.type === 'bpm_start') {
            animateStrokeVisualizer(data.bpm); // Re-start with current BPM
            showPlayerNotification("Master ‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°!");
        }
    });

    // Initial check: if already paired or somehow redirected here, try to setup WebRTC
    // This is useful if a refresh happens, though full session restoration might need more complex logic.
    socket.on('connect', () => {
        // When reconnected, if already in a room, the server might send 'paired' again
        // Or client might proactively try to recreate peer connection if local storage indicates game state
        // For simplicity, rely on server's 'paired' signal to re-initiate WebRTC
    });
  </script>
</body>
</html>
