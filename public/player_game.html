<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dule CumControl - Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/game_styles.css"> <!-- Link to external CSS, assuming it exists -->
    <style>
        /* ************************************************* */
        /* Custom styles for player_game.html to emphasize camera */
        /* and center everything */
        /* ************************************************* */

        /* Override body styles for consistent background and centering */
        body {
            font-family: 'Inter', sans-serif; /* Consistent font with other pages */
            background: linear-gradient(135deg, #1a0033, #32004d, #4d0066); /* Consistent gradient */
            color: #e0e0e0; /* Softer white */
            display: flex;
            flex-direction: column; /* Ensure content stacks vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            min-height: 100vh; /* Ensure full viewport height */
            padding: 20px; /* Add padding for overall content */
            margin: 0; /* Remove body margin */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        .game-area-container.player-area {
            max-width: 900px; /* Max width of the Player game area */
            padding: 20px; /* Reduced padding */
            gap: 15px; /* Reduced spacing between elements */
            background: rgba(46, 46, 46, 0.8); /* Consistent background with lobby rooms */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5); /* Deep shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            width: 100%; /* Take full width on smaller screens */
        }

        h1 {
            color: #ffccff;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 204, 255, 0.5);
            margin-bottom: 20px;
        }

        /* Container for all video elements */
        .all-videos-container {
            display: flex;
            flex-direction: column; /* Stacks remote and local+stroke sections */
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between remote video and local video section */
            width: 100%;
            margin-bottom: 1.5rem;
        }

        /* Style for individual video elements to be responsive */
        .video-element {
            width: 100%; /* Each video takes full width of its container */
            max-width: 450px; /* Limit max width for each video */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 16 / 9;
            background-color: #2a3547; /* Darker grey background */
            border-radius: 0.75rem; /* Rounded corners (rounded-lg) */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25); /* Prominent shadow */
            object-fit: cover; /* Cover video area */
            border: 2px solid #60a5fa; /* Blue border */
            display: none; /* Hide video elements by default */
        }

        /* New flex container to hold Local Video and Stroke Visualizer side-by-side */
        .local-video-and-stroke-flex {
            display: flex;
            flex-direction: row; /* Arranges local video and stroke visualizer side-by-side */
            justify-content: center;
            align-items: flex-start; /* Aligns items to the top (video title) */
            gap: 1rem; /* Space between video and stroke visualizer */
            width: 100%; /* Allows it to take up available width within its parent */
            max-width: 500px; /* Max width to control overall size for desktop */
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .local-video-and-stroke-flex {
                flex-direction: column; /* Stack local video and stroke visualizer vertically on small screens */
                align-items: center; /* Center them when stacked */
                gap: 1.5rem; /* More space when stacked */
            }
        }

        /* Common button styles */
        button {
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
            border-radius: 0.75rem;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        button:hover:enabled {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }

        /* Camera control buttons */
        .camera-controls button {
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            border-radius: 0.6rem;
        }

        /* Timer text */
        #playerGameTimer {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #b3e0ff;
            font-weight: 600;
        }

        /* Stroke Visualizer */
        @keyframes pulseStroke {
            0% { transform: scaleY(0.7); background-color: #ec4899; } /* Start higher to be more visible */
            50% { transform: scaleY(1.3); background-color: #f472b6; } /* Scale up more noticeably */
            100% { transform: scaleY(0.7); background-color: #ec4899; } /* Return to higher base */
        }
        .stroke-visualizer-container {
            width: 20px; /* Width of the visualizer bar itself */
            min-height: 150px; /* Added: Ensures a default minimum height, even if video is not loaded yet */
            background-color: #ec4899; /* pink-500 */
            border-radius: 0.75rem; /* More rounded */
            display: flex; /* Use flexbox to align inner bar */
            justify-content: center;
            align-items: flex-end; /* Align bar to bottom */
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Add shadow */
        }

        #strokeVisualizer {
            width: 100%;
            height: 60%; /* Changed: Initial height increased to be more visible */
            background-color: #fbcfe8; /* pink-300 */
            transition: height 0.1s ease-out, background-color 0.1s ease-out; /* Smooth transition */
        }
        .stroke-pulse {
            animation: pulseStroke 0.3s ease; /* Applied dynamically */
        }

        /* Arousal display */
        .arousal-display-group {
            margin: 1.5rem auto; /* Consistent margin */
            max-width: 400px; /* Consistent max-width */
            width: 90%; /* Consistent width */
            background: rgba(30, 30, 30, 0.6); /* Consistent background */
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        #playerArousalDisplay {
            font-size: 1.1em; /* Consistent font size */
            font-weight: 700;
            color: #ff5252; /* Consistent red color */
        }
        .arousal-bar-container {
            height: 1.2rem; /* Consistent height */
            margin-top: 0.6rem;
            background-color: #4a4a4a; /* Consistent track color */
            border-radius: 0.6rem;
        }
        #playerArousalBar {
            background-color: #f44336; /* Consistent vibrant red */
        }
        .arousal-buttons button {
            padding: 0.6rem 1rem; /* Consistent padding */
            font-size: 0.9em; /* Consistent font size */
            border-radius: 0.6rem; /* Consistent rounded corners */
            margin: 0.2rem; /* Add small margin for button spacing */
        }
        .arousal-max-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Player command buttons */
        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem; /* Increased gap */
            margin: 1.5rem auto;
            max-width: 600px; /* Increased max width for more buttons */
        }
        .controls button {
            padding: 0.8rem 1.6rem; /* Consistent button size */
            font-size: 1.1rem; /* Slightly larger text */
            border-radius: 0.75rem;
            min-width: 120px; /* Ensure minimum width for buttons */
        }
        #playerSlowPleaseBtn {
            background-color: #3b82f6; /* Blue */
        }
        #playerICanCumBtn {
            background-color: #22c55e; /* Green */
        }
        #playerPleaseStopBtn {
            background-color: #f97316; /* Orange */
        }

        /* Notification area (consistent with lobby and master_control) */
        #messageBox {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.3); /* Reddish for error */
            border-radius: 8px;
            color: white;
            font-size: 1em;
            max-width: 400px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            text-align: center; /* Center the message text */
            z-index: 1000; /* Ensure it's on top */
            position: fixed; /* Fixed position */
            top: 20px; /* From top */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust for perfect centering */
        }
        #messageBox.show {
            opacity: 1;
            visibility: visible;
        }
        #messageBox.success {
            background-color: rgba(0, 128, 0, 0.3);
        }
        #messageBox.info {
            background-color: rgba(0, 100, 200, 0.3);
        }

        /* Back to Lobby button */
        #backToLobbyBtnPlayer {
            background-color: #4a5568; /* Darker gray for subtle look */
            color: #cbd5e0;
            border-bottom: 1px solid #718096; /* Subtle underline effect */
            text-decoration: none; /* Remove default underline */
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            margin-top: 2rem;
        }
        #backToLobbyBtnPlayer:hover {
            background-color: #2d3748;
            color: #edf2f7;
            text-decoration: none;
        }

        /* Headings above videos */
        .video-label-container {
            text-align: center;
            margin-bottom: 0.5rem;
            color: #b3e0ff;
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="messageBox" class="message-box"></div>

    <div class="max-w-2xl game-area-container player-area">
        <h1 class="text-3xl font-bold text-center mb-4">Player</h1>

        <p id="playerGameTimer" class="text-lg">เวลาเล่น: 00:00</p>

        <div class="flex justify-center gap-4 my-4 camera-controls">
            <button id="playerOpenCameraBtn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">เปิดกล้อง</button>
            <button id="playerSwapCameraBtn" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded">สลับกล้อง</button>
            <button id="playerStopCameraBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">ปิดกล้อง</button>
        </div>

        <div class="all-videos-container">
            <!-- Remote Video (Master's camera) -->
            <div>
                <h3 class="video-label-container">กล้อง Master</h3>
                <video id="remoteVideo" class="video-element" autoplay playsinline></video>
            </div>

            <!-- Local Video (Your camera) and Stroke Visualizer side-by-side -->
            <div class="local-video-and-stroke-flex">
                <div>
                    <h3 class="video-label-container">กล้องของคุณ</h3>
                    <video id="localVideo" class="video-element" autoplay playsinline muted></video>
                </div>
                <div class="stroke-visualizer-container">
                    <div id="strokeVisualizer" style="height: 60%"></div>
                </div>
            </div>
        </div>

        <div class="text-center mb-6 arousal-display-group">
            <div id="playerArousalDisplay" class="text-lg font-bold">ความเงี่ยนตอนนี้: 5/10</div>
            <div class="w-full bg-gray-600 h-5 rounded relative overflow-hidden my-2 arousal-bar-container">
                <div id="playerArousalBar" class="bg-red-500 h-full transition-all duration-300" style="width: 50%"></div>
                <span class="absolute right-2 top-1/2 -translate-y-1/2 text-xs arousal-max-label">CUM</span>
            </div>
            <div class="flex justify-center gap-4 arousal-buttons">
                <button id="decreaseArousalBtn" class="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded">ลดระดับ</button>
                <button id="increaseArousalBtn" class="bg-green-500 hover:bg-green-600 px-4 py-2 rounded">เพิ่มระดับ</button>
            </div>
        </div>

        <div class="flex justify-center gap-4 mb-4 controls">
            <button id="playerSlowPleaseBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">slow please</button>
            <button id="playerICanCumBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded">I can cum</button>
            <button id="playerPleaseStopBtn" class="bg-orange-500 hover:bg-orange-600 px-4 py-2 rounded">please stop</button>
        </div>

        <div class="text-center mt-8">
            <button id="backToLobbyBtnPlayer" class="underline text-sm">กลับไปล็อบบี้</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // NEW: All JavaScript code is now wrapped in DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // Global socket connection
            const socket = io();

            // Global variables for WebRTC and game state
            let peerConnection;
            let localStream;
            let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
            let videoSender = null; // To store the RTCRtpSender for the video track for replaceTrack
            let myRoom; // Global variable for current room
            let myRole; // Global variable for current role

            // WebRTC Config with STUN servers
            const rtcConfig = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ]
            };

            // Player Game Logic variables
            const maxArousal = 10;
            let playerArousalLevel = 5;
            let playerGameElapsedTime = 0;
            let playerElapsedTimeInterval = null; // Interval ID for game timer
            let strokeInterval; // For BPM animation

            // DOM Elements
            const localVideo = document.getElementById('localVideo');
            const remoteVideo = document.getElementById('remoteVideo');
            const playerGameTimer = document.getElementById('playerGameTimer');
            const playerArousalDisplay = document.getElementById('playerArousalDisplay');
            const playerArousalBar = document.getElementById('playerArousalBar');
            const increaseArousalBtn = document.getElementById('increaseArousalBtn');
            const decreaseArousalBtn = document.getElementById('decreaseArousalBtn');
            const playerSlowPleaseBtn = document.getElementById('playerSlowPleaseBtn');
            const playerICanCumBtn = document.getElementById('playerICanCumBtn');
            const playerPleaseStopBtn = document.getElementById('playerPleaseStopBtn');
            const backToLobbyBtnPlayer = document.getElementById('backToLobbyBtnPlayer');
            const playerOpenCameraBtn = document.getElementById('playerOpenCameraBtn');
            const playerSwapCameraBtn = document.getElementById('playerSwapCameraBtn');
            const playerStopCameraBtn = document.getElementById('playerStopCameraBtn');
            const strokeVisualizer = document.getElementById('strokeVisualizer');
            const strokeVisualizerContainer = document.querySelector('.stroke-visualizer-container');
            const messageBox = document.getElementById('messageBox');


            // Function to play stroke sound (Tone.js could be used for more control)
            function playStrokeSound() {
                try {
                    const audio = new Audio('/sounds/stroke.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.warn("Cannot play audio: ", e));
                } catch (e) {
                    console.error("Error creating audio object:", e);
                }
            }

            // Function to display custom messages (consistent with other pages)
            function showMessage(message, type = 'error') {
                messageBox.textContent = message;
                messageBox.className = 'message-box show'; // Reset classes and show
                messageBox.classList.add(type); // Add specific type class for styling
                setTimeout(() => {
                    messageBox.classList.remove('show');
                }, 3000);
            }

            // Function to update arousal display
            function updateArousalDisplay() {
                playerArousalDisplay.textContent = `ความเงี่ยนตอนนี้: ${playerArousalLevel}/${maxArousal}`;
                playerArousalBar.style.width = `${(playerArousalLevel / maxArousal) * 100}%`;
                socket.emit("playerArousalUpdate", playerArousalLevel); // Emit to Master via Socket.IO
            }

            // Function to synchronize stroke visualizer height with local video
            function syncStrokeVisualizerHeight() {
                if (localVideo && strokeVisualizerContainer && localVideo.style.display !== 'none') {
                    requestAnimationFrame(() => {
                        const videoHeight = localVideo.offsetHeight;
                        if (videoHeight > 0) {
                            strokeVisualizerContainer.style.height = `${videoHeight}px`;
                        }
                    });
                } else {
                    strokeVisualizerContainer.style.height = `200px`; // Fallback height if video is hidden
                }
            }

            // Function to animate the stroke visualizer
            function animateStrokeVisualizer(bpm) {
                if (strokeInterval) clearInterval(strokeInterval);

                if (bpm === 0) {
                    strokeVisualizer.style.height = '0%';
                    strokeVisualizer.classList.remove('stroke-pulse');
                    return;
                }

                const intervalMs = 60000 / bpm;

                strokeInterval = setInterval(() => {
                    strokeVisualizer.style.height = '100%';
                    strokeVisualizer.classList.add('stroke-pulse');
                    if (bpm >= 140) playStrokeSound();

                    setTimeout(() => {
                        strokeVisualizer.style.height = '60%';
                        setTimeout(() => {
                            strokeVisualizer.classList.remove('stroke-pulse');
                        }, 300);
                    }, intervalMs / 2);
                }, intervalMs);
            }

            // Camera and WebRTC Functions
            async function startCamera(facingMode = 'user') {
                console.log(`[Player] Attempting to start camera with facing mode: ${facingMode}`);
                if (localStream) {
                    console.log('[Player] Stopping existing local stream tracks.');
                    localStream.getTracks().forEach(track => track.stop());
                    localVideo.srcObject = null;
                }
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: facingMode },
                        audio: false // Player does not need to send audio
                    });
                    console.log('[Player] Got local stream:', localStream);
                    localVideo.srcObject = localStream;
                    localVideo.style.display = 'block';
                    currentFacingMode = facingMode;
                    showMessage("กล้องเปิดแล้ว", 'success');

                    if (peerConnection) {
                        console.log('[Player] Peer connection exists, adding/replacing tracks.');
                        const videoTrack = localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            if (videoSender) {
                                console.log('[Player] Replacing existing video track.');
                                await videoSender.replaceTrack(videoTrack);
                            } else {
                                console.log('[Player] Adding new video track.');
                                videoSender = peerConnection.addTrack(videoTrack, localStream);
                            }
                        }
                    } else {
                        console.log('[Player] Peer connection not yet created when startCamera was called. Tracks will be added later.');
                    }
                } catch (e) {
                    console.error("ไม่สามารถเข้าถึงกล้องได้: ", e);
                    let errorMessage = "ไม่สามารถเข้าถึงกล้องได้";
                    if (e.name === "NotAllowedError") {
                        errorMessage += ": ไม่ได้รับอนุญาตให้ใช้กล้อง (โปรดตรวจสอบการอนุญาตของเบราว์เซอร์)";
                    } else if (e.name === "NotFoundError") {
                        errorMessage += ": ไม่พบอุปกรณ์กล้อง";
                    } else {
                        errorMessage += `: ${e.message}`;
                    }
                    showMessage(errorMessage, 'error');
                }
            }

            function stopCamera() {
                console.log('[Player] Stopping camera.');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                    localVideo.srcObject = null;
                    localVideo.style.display = 'none';
                    showMessage("กล้องปิดแล้ว", 'info');

                    // Remove tracks from peer connection if it exists
                    if (peerConnection) {
                        peerConnection.getSenders().forEach(sender => {
                            if (sender.track && sender.track.kind === 'video') {
                                peerConnection.removeTrack(sender);
                                console.log(`[Player] Removed video track from peer connection.`);
                            }
                        });
                        videoSender = null; // Clear video sender reference
                    }
                }
                syncStrokeVisualizerHeight();
            }

            async function switchCamera() {
                console.log('[Player] Switching camera.');
                const newFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
                await startCamera(newFacingMode);
            }

            // WebRTC Setup: Create Peer Connection
            function createPeerConnection() {
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    console.warn("[Player] Peer connection already exists and is not closed. Skipping creation.");
                    return;
                }

                peerConnection = new RTCPeerConnection(rtcConfig);
                console.log("[Player] RTCPeerConnection created.");

                // NEW: Add local stream tracks to peer connection if available immediately
                // This ensures tracks are associated with the PC as soon as it's created.
                if (localStream) {
                    console.log('[Player] Local stream exists, adding tracks during peer connection creation.');
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoSender = peerConnection.addTrack(videoTrack, localStream);
                        console.log('[Player] Added initial video track to peer connection during creation.');
                    }
                } else {
                    console.log('[Player] Local stream not available during peer connection creation. Will add tracks when startCamera is called.');
                }

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('[Player] Sending ICE candidate:', event.candidate);
                        socket.emit('signal', { room: myRoom, candidate: event.candidate }); // Pass myRoom with the signal
                    }
                };

                peerConnection.ontrack = (event) => {
                    console.log('[Player] Received remote track event:', event.streams);
                    if (remoteVideo.srcObject !== event.streams[0]) {
                        remoteVideo.srcObject = event.streams[0];
                        remoteVideo.style.display = 'block';
                        showMessage('ได้รับสตรีมวิดีโอจาก Master แล้ว', 'success');
                        console.log('[Player] Received remote stream from Master.');
                    }
                };

                // Add more detailed logging for WebRTC states
                peerConnection.onconnectionstatechange = () => {
                    console.log('[Player] WebRTC connection state changed:', peerConnection.connectionState);
                    if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                        showMessage('การเชื่อมต่อ WebRTC หลุด/ล้มเหลว', 'error');
                    } else if (peerConnection.connectionState === 'connected') {
                        showMessage('เชื่อมต่อ WebRTC กับ Master สำเร็จ!', 'success');
                    }
                };

                peerConnection.onsignalingstatechange = () => {
                    console.log('[Player] WebRTC signaling state changed:', peerConnection.signalingState);
                };

                peerConnection.onicegatheringstatechange = () => {
                    console.log('[Player] WebRTC ICE gathering state changed:', peerConnection.iceGatheringState);
                };
                
                peerConnection.onnegotiationneeded = async () => {
                    console.log('[Player] WebRTC negotiation needed event fired.');
                    // This is handled by the initial offer/answer flow and track additions.
                    // No explicit action needed here unless specific re-negotiation is required.
                };
            }

            // Socket.IO Listeners for WebRTC Signaling
            socket.on('paired', async ({ role, room }) => {
                console.log(`[Player] Paired event received: role=${role}, room=${room}`);
                showMessage('จับคู่สำเร็จ! เตรียมพร้อมสำหรับเกม', 'success');
                // Store room and role globally
                myRoom = room;
                myRole = role;

                createPeerConnection(); // 1. Create peer connection
                await startCamera(); // 2. Get local stream and add tracks to the peer connection

                // Player waits for offer from Master, then sends answer.
            });

            socket.on('signal', async (data) => {
                console.log(`[Player] Signal received: type=${data.sdp ? data.sdp.type : 'candidate'}`);
                // Ensure myRoom is set before processing signals
                if (!myRoom && data.room) {
                    myRoom = data.room; // Try to get room from incoming signal if not set
                    console.log(`[Player] myRoom was not set, initialized from signal data: ${myRoom}`);
                }

                if (!peerConnection || peerConnection.signalingState === 'closed') {
                    console.warn('[Player] PeerConnection not initialized or closed, recreating and starting camera.');
                    createPeerConnection(); // Recreate PC if closed or not initialized
                    await startCamera(); // Ensure camera/stream is ready after PC
                }

                if (data.sdp) {
                    console.log('[Player] Received SDP:', data.sdp.type);
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

                        if (data.sdp.type === 'offer') {
                            console.log('[Player] Received offer from Master, creating answer...');
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            socket.emit('signal', { room: myRoom, sdp: answer }); // Pass myRoom with the answer signal
                            console.log('[Player] WebRTC answer sent.');
                        } else if (data.sdp.type === 'answer') {
                            console.log('[Player] Received answer from Master (unexpected for Player, but handled defensively)');
                        }
                    } catch (e) {
                        console.error("[Player] Error setting remote description or creating answer:", e);
                        showMessage("เกิดข้อผิดพลาดในการรับ/ส่งข้อมูล WebRTC: " + e.message, 'error');
                    }
                } else if (data.candidate) {
                    console.log('[Player] Received ICE candidate:', data.candidate);
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } catch (e) {
                        console.error("[Player] Error adding ICE candidate:", e);
                        showMessage("เกิดข้อผิดพลาดในการเพิ่ม ICE candidate: " + e.message, 'error');
                    }
                }
            });

            // Handle partner disconnected
            socket.on('partnerDisconnected', (message) => {
                console.log('[Player] Partner disconnected event received.');
                showMessage(message + "\nคุณจะถูกนำกลับไปยังล็อบบี้", 'info');
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    peerConnection.close();
                    peerConnection = null;
                    videoSender = null;
                }
                stopCamera();
                remoteVideo.srcObject = null;
                remoteVideo.style.display = 'none';
                if (playerElapsedTimeInterval) {
                    clearInterval(playerElapsedTimeInterval);
                    playerElapsedTimeInterval = null;
                }
                if (strokeInterval) {
                    clearInterval(strokeInterval);
                    strokeInterval = null;
                    strokeVisualizer.style.height = '0%';
                    strokeVisualizer.classList.remove('stroke-pulse');
                }
                setTimeout(() => {
                    window.location.href = '/lobby.html';
                }, 3000);
            });


            // --- Event Listeners for DOM elements ---
            console.log('[Player] DOM Content Loaded.');
            // Initialize myRoom and myRole from URL parameters on page load
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('room') && urlParams.has('role')) {
                myRoom = parseInt(urlParams.get('room'));
                myRole = urlParams.get('role');
                console.log(`[Player] Initialized from URL: Room ${myRoom}, Role ${myRole}`);
            } else {
                console.log('[Player] No room/role in URL. Assuming fresh load or direct access.');
            }

            updateArousalDisplay();
            syncStrokeVisualizerHeight();

            let seconds = 0;
            playerElapsedTimeInterval = setInterval(() => {
                seconds++;
                const m = String(Math.floor(seconds / 60)).padStart(2, '0');
                const s = String(seconds % 60).padStart(2, '0');
                playerGameTimer.textContent = `เวลาเล่น: ${m}:${s}`;
            }, 1000);

            increaseArousalBtn.addEventListener('click', () => {
                if (playerArousalLevel < maxArousal) {
                    playerArousalLevel++;
                    updateArousalDisplay();
                    showMessage("เพิ่มระดับความเงี่ยน", 'info');
                } else {
                    showMessage("ความเงี่ยนถึงระดับสูงสุดแล้ว!", 'info');
                }
            });

            decreaseArousalBtn.addEventListener('click', () => {
                if (playerArousalLevel > 1) {
                    playerArousalLevel--;
                    updateArousalDisplay();
                    showMessage("ลดระดับความเงี่ยน", 'info');
                } else {
                    showMessage("ความเงี่ยนถึงระดับต่ำสุดแล้ว!", 'info');
                }
            });

            playerOpenCameraBtn.addEventListener('click', () => startCamera());
            playerSwapCameraBtn.addEventListener('click', switchCamera);
            playerStopCameraBtn.addEventListener('click', stopCamera);

            playerSlowPleaseBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { room: myRoom, type: 'slow_please', message: 'Player: slow please' }); // Pass myRoom
                showMessage('ส่งคำขอ: Slow Please!', 'success');
            });
            playerICanCumBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { room: myRoom, type: 'i_can_cum', message: 'Player: I can cum' }); // Pass myRoom
                showMessage('ส่งคำขอ: I Can Cum!', 'success');
            });
            playerPleaseStopBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { room: myRoom, type: 'please_stop', message: 'Player: please stop' }); // Pass myRoom
                showMessage('ส่งคำขอ: Please Stop!', 'success');
            });

            backToLobbyBtnPlayer.addEventListener('click', () => {
                console.log('[Player] Back to Lobby button clicked.');
                showMessage("กำลังกลับสู่ล็อบบี้...", 'info');
                socket.emit('leaveRoom');
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    console.log('[Player] Closing peer connection on leave.');
                    peerConnection.close();
                    peerConnection = null;
                    videoSender = null;
                }
                stopCamera();
                remoteVideo.srcObject = null;
                remoteVideo.style.display = 'none';
                if (playerElapsedTimeInterval) {
                    clearInterval(playerElapsedTimeInterval);
                    playerElapsedTimeInterval = null;
                }
                if (strokeInterval) {
                    clearInterval(strokeInterval);
                    strokeInterval = null;
                    strokeVisualizer.style.height = '0%';
                    strokeVisualizer.classList.remove('stroke-pulse');
                }
                setTimeout(() => {
                    window.location.href = '/lobby.html';
                }, 1500);
            });

            window.addEventListener('resize', syncStrokeVisualizerHeight);
        }); // End of DOMContentLoaded

        // Socket.IO Listeners for game commands from Master
        socket.on('masterCommand', (data) => {
            console.log("Player received command from Master:", data);
            if (data.type === 'cum_now') {
                showMessage("Master สั่งให้คุณหลั่ง! 💦💦💦", 'success');
                playerArousalLevel = maxArousal;
                updateArousalDisplay();
            } else if (data.type === 'dont_touch') {
                showMessage(data.message, 'error');
            } else if (data.type === 'ok' || data.type === 'no') {
                showMessage(data.message, 'info');
            } else if (data.type === 'bpm_update') {
                animateStrokeVisualizer(data.bpm);
                showMessage(`ความเร็ว: ${data.bpm} BPM`, 'info');
            } else if (data.type === 'bpm_stop') {
                animateStrokeVisualizer(0);
                showMessage("Master สั่งหยุด!", 'info');
            } else if (data.type === 'bpm_start') { // Re-added bpm_start handler
                animateStrokeVisualizer(data.bpm);
                showMessage("Master สั่งเริ่ม!", 'info');
            }
        });

        // Handle initial connection or reconnection - server typically sends 'paired'
        socket.on('connect', () => {
            console.log('[Player] Player connected to Socket.IO server.');
            // When reconnecting, the server.js 'disconnect' handler and 'partnerDisconnected' event
            // are designed to redirect to lobby if partner leaves. If player just refreshes
            // and partner is still active, server should ideally re-send 'paired' or equivalent state.
            // For now, if server does not re-send 'paired', the client will stay on game page but
            // WebRTC might not fully re-establish without manual intervention.
        });

        socket.on('disconnect', () => {
            console.log('[Player] Player disconnected from Socket.IO server.');
            // This is handled by partnerDisconnected if partner leaves, or by server.js disconnect handler.
            // Client-side should clear state when this happens to avoid ghosting.
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                videoSender = null;
            }
            stopCamera();
            remoteVideo.srcObject = null;
            remoteVideo.style.display = 'none';
            if (playerElapsedTimeInterval) {
                clearInterval(playerElapsedTimeInterval);
                playerElapsedTimeInterval = null;
            }
            if (strokeInterval) {
                clearInterval(strokeInterval);
                strokeInterval = null;
                strokeVisualizer.style.height = '0%';
                strokeVisualizer.classList.remove('stroke-pulse');
            }
        });
    </script>
</body>
</html>
