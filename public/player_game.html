<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dule CumControl - Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/game_styles.css"> <!-- Link to external CSS, assuming it exists -->
    <style>
        /* ************************************************* */
        /* Custom styles for player_game.html to emphasize camera */
        /* and center everything */
        /* ************************************************* */

        /* Override body styles for consistent background and centering */
        body {
            font-family: 'Inter', sans-serif; /* Consistent font with other pages */
            background: linear-gradient(135deg, #1a0033, #32004d, #4d0066); /* Consistent gradient */
            color: #e0e0e0; /* Softer white */
            display: flex;
            flex-direction: column; /* Ensure content stacks vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            min-height: 100vh; /* Ensure full viewport height */
            padding: 20px; /* Add padding for overall content */
            margin: 0; /* Remove body margin */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        .game-area-container.player-area {
            max-width: 900px; /* Max width of the Player game area */
            padding: 20px; /* Reduced padding */
            gap: 15px; /* Reduced spacing between elements */
            background: rgba(46, 46, 46, 0.8); /* Consistent background with lobby rooms */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5); /* Deep shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            width: 100%; /* Take full width on smaller screens */
        }

        h1 {
            color: #ffccff;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 204, 255, 0.5);
            margin-bottom: 20px;
        }

        /* Container for all video elements */
        .all-videos-container {
            display: flex;
            flex-direction: column; /* Stacks remote and local+stroke sections */
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between remote video and local video section */
            width: 100%;
            margin-bottom: 1.5rem;
        }

        /* Style for individual video elements to be responsive */
        .video-element {
            width: 100%; /* Each video takes full width of its container */
            max-width: 450px; /* Limit max width for each video */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 16 / 9;
            background-color: #2a3547; /* Darker grey background */
            border-radius: 0.75rem; /* Rounded corners (rounded-lg) */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25); /* Prominent shadow */
            object-fit: cover; /* Cover video area */
            border: 2px solid #60a5fa; /* Blue border */
            display: none; /* Hide video elements by default */
        }

        /* New flex container to hold Local Video and Stroke Visualizer side-by-side */
        .local-video-and-stroke-flex {
            display: flex;
            flex-direction: row; /* Arranges local video and stroke visualizer side-by-side */
            justify-content: center;
            align-items: flex-start; /* Aligns items to the top (video title) */
            gap: 1rem; /* Space between video and stroke visualizer */
            width: 100%; /* Allows it to take up available width within its parent */
            max-width: 500px; /* Max width to control overall size for desktop */
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .local-video-and-stroke-flex {
                flex-direction: column; /* Stack local video and stroke visualizer vertically on small screens */
                align-items: center; /* Center them when stacked */
                gap: 1.5rem; /* More space when stacked */
            }
        }

        /* Common button styles */
        button {
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
            border-radius: 0.75rem;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        button:hover:enabled {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }

        /* Camera control buttons */
        .camera-controls button {
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            border-radius: 0.6rem;
        }

        /* Timer text */
        #playerGameTimer {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #b3e0ff;
            font-weight: 600;
        }

        /* Stroke Visualizer */
        @keyframes pulseStroke {
            0% { transform: scaleY(0.7); background-color: #ec4899; } /* Start higher to be more visible */
            50% { transform: scaleY(1.3); background-color: #f472b6; } /* Scale up more noticeably */
            100% { transform: scaleY(0.7); background-color: #ec4899; } /* Return to higher base */
        }
        .stroke-visualizer-container {
            width: 20px; /* Width of the visualizer bar itself */
            min-height: 150px; /* Added: Ensures a default minimum height, even if video is not loaded yet */
            background-color: #ec4899; /* pink-500 */
            border-radius: 0.75rem; /* More rounded */
            display: flex; /* Use flexbox to align inner bar */
            justify-content: center;
            align-items: flex-end; /* Align bar to bottom */
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Add shadow */
        }

        #strokeVisualizer {
            width: 100%;
            height: 60%; /* Changed: Initial height increased to be more visible */
            background-color: #fbcfe8; /* pink-300 */
            transition: height 0.1s ease-out, background-color 0.1s ease-out; /* Smooth transition */
        }
        .stroke-pulse {
            animation: pulseStroke 0.3s ease; /* Applied dynamically */
        }

        /* Arousal display */
        .arousal-display-group {
            margin: 1.5rem auto; /* Consistent margin */
            max-width: 400px; /* Consistent max-width */
            width: 90%; /* Consistent width */
            background: rgba(30, 30, 30, 0.6); /* Consistent background */
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        #playerArousalDisplay {
            font-size: 1.1em; /* Consistent font size */
            font-weight: 700;
            color: #ff5252; /* Consistent red color */
        }
        .arousal-bar-container {
            height: 1.2rem; /* Consistent height */
            margin-top: 0.6rem;
            background-color: #4a4a4a; /* Consistent track color */
            border-radius: 0.6rem;
        }
        #playerArousalBar {
            background-color: #f44336; /* Consistent vibrant red */
        }
        .arousal-buttons button {
            padding: 0.6rem 1rem; /* Consistent padding */
            font-size: 0.9em; /* Consistent font size */
            border-radius: 0.6rem; /* Consistent rounded corners */
            margin: 0.2rem; /* Add small margin for button spacing */
        }
        .arousal-max-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Player command buttons */
        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem; /* Increased gap */
            margin: 1.5rem auto;
            max-width: 600px; /* Increased max width for more buttons */
        }
        .controls button {
            padding: 0.8rem 1.6rem; /* Consistent button size */
            font-size: 1.1rem; /* Slightly larger text */
            border-radius: 0.75rem;
            min-width: 120px; /* Ensure minimum width for buttons */
        }
        #playerSlowPleaseBtn {
            background-color: #3b82f6; /* Blue */
        }
        #playerICanCumBtn {
            background-color: #22c55e; /* Green */
        }
        #playerPleaseStopBtn {
            background-color: #f97316; /* Orange */
        }

        /* Notification area (consistent with lobby and master_control) */
        #messageBox {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.3); /* Reddish for error */
            border-radius: 8px;
            color: white;
            font-size: 1em;
            max-width: 400px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 1000; /* Ensure it's on top */
            position: fixed; /* Fixed position */
            top: 20px; /* From top */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust for perfect centering */
        }
        #messageBox.show {
            opacity: 1;
            visibility: visible;
        }
        #messageBox.success {
            background-color: rgba(0, 128, 0, 0.3);
        }
        #messageBox.info {
            background-color: rgba(0, 100, 200, 0.3);
        }

        /* Back to Lobby button */
        #backToLobbyBtnPlayer {
            background-color: #4a5568; /* Darker gray for subtle look */
            color: #cbd5e0;
            border-bottom: 1px solid #718096; /* Subtle underline effect */
            text-decoration: none; /* Remove default underline */
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            margin-top: 2rem;
        }
        #backToLobbyBtnPlayer:hover {
            background-color: #2d3748;
            color: #edf2f7;
            text-decoration: none;
        }

        /* Headings above videos */
        .video-label-container {
            text-align: center;
            margin-bottom: 0.5rem;
            color: #b3e0ff;
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="messageBox" class="message-box"></div>

    <div class="max-w-2xl game-area-container player-area">
        <h1 class="text-3xl font-bold text-center mb-4">Player</h1>

        <p id="playerGameTimer" class="text-lg">เวลาเล่น: 00:00</p>

        <div class="flex justify-center gap-4 my-4 camera-controls">
            <button id="playerOpenCameraBtn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">เปิดกล้อง</button>
            <button id="playerSwapCameraBtn" class="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded">สลับกล้อง</button>
            <button id="playerStopCameraBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded">ปิดกล้อง</button>
        </div>

        <div class="all-videos-container">
            <!-- Remote Video (Master's camera) -->
            <div>
                <h3 class="video-label-container">กล้อง Master</h3>
                <video id="remoteVideo" class="video-element" autoplay playsinline></video>
            </div>

            <!-- Local Video (Your camera) and Stroke Visualizer side-by-side -->
            <div class="local-video-and-stroke-flex">
                <div>
                    <h3 class="video-label-container">กล้องของคุณ</h3>
                    <video id="localVideo" class="video-element" autoplay playsinline muted></video>
                </div>
                <div class="stroke-visualizer-container">
                    <div id="strokeVisualizer" style="height: 60%"></div>
                </div>
            </div>
        </div>

        <div class="text-center mb-6 arousal-display-group">
            <div id="playerArousalDisplay" class="text-lg font-bold">ความเงี่ยนตอนนี้: 5/10</div>
            <div class="w-full bg-gray-600 h-5 rounded relative overflow-hidden my-2 arousal-bar-container">
                <div id="playerArousalBar" class="bg-red-500 h-full transition-all duration-300" style="width: 50%"></div>
                <span class="absolute right-2 top-1/2 -translate-y-1/2 text-xs arousal-max-label">CUM</span>
            </div>
            <div class="flex justify-center gap-4 arousal-buttons">
                <button id="decreaseArousalBtn" class="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded">ลดระดับ</button>
                <button id="increaseArousalBtn" class="bg-green-500 hover:bg-green-600 px-4 py-2 rounded">เพิ่มระดับ</button>
            </div>
        </div>

        <div class="flex justify-center gap-4 mb-4 controls">
            <button id="playerSlowPleaseBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">slow please</button>
            <button id="playerICanCumBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded">I can cum</button>
            <button id="playerPleaseStopBtn" class="bg-orange-500 hover:bg-orange-600 px-4 py-2 rounded">please stop</button>
        </div>

        <div class="text-center mt-8">
            <button id="backToLobbyBtnPlayer" class="underline text-sm">กลับไปล็อบบี้</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Global socket connection
        const socket = io();

        // Global variables for WebRTC and game state
        let peerConnection;
        let localStream;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let videoSender = null; // To store the RTCRtpSender for the video track for replaceTrack
        let myRoom; // Global variable for current room
        let myRole; // Global variable for current role

        // WebRTC Config with STUN servers
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        // Player Game Logic variables
        const maxArousal = 10;
        let playerArousalLevel = 5;
        let playerGameElapsedTime = 0;
        let playerElapsedTimeInterval = null; // Interval ID for game timer
        let strokeInterval; // For BPM animation

        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const playerGameTimer = document.getElementById('playerGameTimer');
        const playerArousalDisplay = document.getElementById('playerArousalDisplay');
        const playerArousalBar = document.getElementById('playerArousalBar');
        const increaseArousalBtn = document.getElementById('increaseArousalBtn');
        const decreaseArousalBtn = document.getElementById('decreaseArousalBtn');
        const playerSlowPleaseBtn = document.getElementById('playerSlowPleaseBtn');
        const playerICanCumBtn = document.getElementById('playerICanCumBtn');
        const playerPleaseStopBtn = document.getElementById('playerPleaseStopBtn');
        const backToLobbyBtnPlayer = document.getElementById('backToLobbyBtnPlayer');
        const playerOpenCameraBtn = document.getElementById('playerOpenCameraBtn');
        const playerSwapCameraBtn = document.getElementById('playerSwapCameraBtn');
        const playerStopCameraBtn = document.getElementById('playerStopCameraBtn');
        const strokeVisualizer = document.getElementById('strokeVisualizer');
        const strokeVisualizerContainer = document.querySelector('.stroke-visualizer-container');
        const messageBox = document.getElementById('messageBox');


        // Function to play stroke sound (Tone.js could be used for more control)
        function playStrokeSound() {
            try {
                const audio = new Audio('/sounds/stroke.mp3');
                audio.volume = 0.3;
                audio.play().catch(e => console.warn("Cannot play audio: ", e));
            } catch (e) {
                console.error("Error creating audio object:", e);
            }
        }

        // Function to display custom messages (consistent with other pages)
        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = 'message-box show'; // Reset classes and show
            messageBox.classList.add(type); // Add specific type class for styling
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }

        // Function to update arousal display
        function updateArousalDisplay() {
            playerArousalDisplay.textContent = `ความเงี่ยนตอนนี้: ${playerArousalLevel}/${maxArousal}`;
            playerArousalBar.style.width = `${(playerArousalLevel / maxArousal) * 100}%`;
            socket.emit("playerArousalUpdate", playerArousalLevel); // Emit to Master via Socket.IO
        }

        // Function to synchronize stroke visualizer height with local video
        function syncStrokeVisualizerHeight() {
            if (localVideo && strokeVisualizerContainer && localVideo.style.display !== 'none') {
                requestAnimationFrame(() => {
                    const videoHeight = localVideo.offsetHeight;
                    if (videoHeight > 0) {
                        strokeVisualizerContainer.style.height = `${videoHeight}px`;
                    }
                });
            } else {
                 strokeVisualizerContainer.style.height = `200px`; // Fallback height if video is hidden
            }
        }

        // Function to animate the stroke visualizer
        function animateStrokeVisualizer(bpm) {
            if (strokeInterval) clearInterval(strokeInterval);

            if (bpm === 0) {
                strokeVisualizer.style.height = '0%';
                strokeVisualizer.classList.remove('stroke-pulse');
                return;
            }

            const intervalMs = 60000 / bpm;

            strokeInterval = setInterval(() => {
                strokeVisualizer.style.height = '100%';
                strokeVisualizer.classList.add('stroke-pulse');
                if (bpm >= 140) playStrokeSound();

                setTimeout(() => {
                    strokeVisualizer.style.height = '60%';
                    setTimeout(() => {
                        strokeVisualizer.classList.remove('stroke-pulse');
                    }, 300);
                }, intervalMs / 2);
            }, intervalMs);
        }

        // Camera and WebRTC Functions
        async function startCamera(facingMode = 'user') {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null;
            }
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode },
                    audio: false // Player does not need to send audio
                });
                localVideo.srcObject = localStream;
                localVideo.style.display = 'block';
                currentFacingMode = facingMode;
                showMessage("กล้องเปิดแล้ว", 'success');

                if (peerConnection) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        if (videoSender) {
                            await videoSender.replaceTrack(videoTrack);
                            console.log('Replaced video track in peer connection');
                        } else {
                            videoSender = peerConnection.addTrack(videoTrack, localStream);
                            console.log('Added video track for the first time to peer connection');
                        }
                    }
                }
            } catch (e) {
                console.error("ไม่สามารถเข้าถึงกล้องได้: ", e);
                let errorMessage = "ไม่สามารถเข้าถึงกล้องได้";
                if (e.name === "NotAllowedError") {
                    errorMessage += ": ไม่ได้รับอนุญาตให้ใช้กล้อง (โปรดตรวจสอบการอนุญาตของเบราว์เซอร์)";
                } else if (e.name === "NotFoundError") {
                    errorMessage += ": ไม่พบอุปกรณ์กล้อง";
                } else {
                    errorMessage += `: ${e.message}`;
                }
                showMessage(errorMessage, 'error');
            }
        }

        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                localVideo.style.display = 'none';
                showMessage("กล้องปิดแล้ว", 'info');
            }
            syncStrokeVisualizerHeight();
        }

        async function switchCamera() {
            const newFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            await startCamera(newFacingMode);
        }

        // WebRTC Setup: Create Peer Connection
        function createPeerConnection() {
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                console.warn("Peer connection already exists and is not closed. Skipping creation.");
                return;
            }

            peerConnection = new RTCPeerConnection(rtcConfig);
            console.log("RTCPeerConnection created.");

            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoSender = peerConnection.addTrack(videoTrack, localStream);
                }
            }

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate);
                    socket.emit('signal', { room: myRoom, candidate: event.candidate }); // Pass myRoom with the signal
                }
            };

            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block';
                    showMessage('ได้รับสตรีมวิดีโอจาก Master แล้ว', 'success');
                    console.log('Received remote stream');
                }
            };

            peerConnection.onconnectionstatechange = (event) => {
                console.log('WebRTC connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    showMessage('การเชื่อมต่อ WebRTC หลุด/ล้มเหลว', 'error');
                } else if (peerConnection.connectionState === 'connected') {
                    showMessage('เชื่อมต่อ WebRTC กับ Master สำเร็จ!', 'success');
                }
            };

            peerConnection.onsignalingstatechange = (event) => {
                console.log('WebRTC signaling state:', peerConnection.signalingState);
            };
        }

        // Socket.IO Listeners for WebRTC Signaling
        socket.on('paired', async ({ role, room }) => {
            showMessage('จับคู่สำเร็จ! เตรียมพร้อมสำหรับเกม', 'success');
            // Store room and role globally
            myRoom = room;
            myRole = role;

            await startCamera(); // Start camera automatically when paired
            createPeerConnection(); // Create peer connection when paired

            // Player waits for offer from Master, then sends answer.
        });

        socket.on('signal', async (data) => {
            // Ensure myRoom is set before processing signals
            if (!myRoom && data.room) {
                myRoom = data.room; // Try to get room from incoming signal if not set
            }
            if (!peerConnection || peerConnection.signalingState === 'closed') {
                await startCamera(); // Ensure camera/stream is ready before creating PC
                createPeerConnection();
            }

            if (data.sdp) {
                console.log('Received SDP:', data.sdp.type);
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

                    if (data.sdp.type === 'offer') {
                        console.log('Received offer from Master, creating answer...');
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        socket.emit('signal', { room: myRoom, sdp: answer }); // Pass myRoom with the answer signal
                        console.log('WebRTC answer sent.');
                    } else if (data.sdp.type === 'answer') {
                        console.log('Received answer from Master (unexpected for Player, but handled)');
                    }
                } catch (e) {
                    console.error("Error setting remote description or creating answer:", e);
                    showMessage("เกิดข้อผิดพลาดในการรับ/ส่งข้อมูล WebRTC: " + e.message, 'error');
                }
            } else if (data.candidate) {
                console.log('Received ICE candidate:', data.candidate);
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                    showMessage("เกิดข้อผิดพลาดในการเพิ่ม ICE candidate: " + e.message, 'error');
                }
            }
        });

        // Handle partner disconnected
        socket.on('partnerDisconnected', (message) => {
            showMessage(message + "\nคุณจะถูกนำกลับไปยังล็อบบี้", 'info');
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                peerConnection.close();
                peerConnection = null;
                videoSender = null;
            }
            stopCamera();
            remoteVideo.srcObject = null;
            remoteVideo.style.display = 'none';
            if (playerElapsedTimeInterval) {
                clearInterval(playerElapsedTimeInterval);
                playerElapsedTimeInterval = null;
            }
            if (strokeInterval) {
                clearInterval(strokeInterval);
                strokeInterval = null;
                strokeVisualizer.style.height = '0%';
                strokeVisualizer.classList.remove('stroke-pulse');
            }
            setTimeout(() => {
                window.location.href = '/lobby.html';
            }, 3000);
        });


        // --- Event Listeners for DOM elements ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize myRoom and myRole from URL parameters on page load
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('room') && urlParams.has('role')) {
                myRoom = parseInt(urlParams.get('room'));
                myRole = urlParams.get('role');
                console.log(`Initialized from URL: Room ${myRoom}, Role ${myRole}`);
            }

            updateArousalDisplay();
            syncStrokeVisualizerHeight();

            let seconds = 0;
            playerElapsedTimeInterval = setInterval(() => {
                seconds++;
                const m = String(Math.floor(seconds / 60)).padStart(2, '0');
                const s = String(seconds % 60).padStart(2, '0');
                playerGameTimer.textContent = `เวลาเล่น: ${m}:${s}`;
            }, 1000);

            increaseArousalBtn.addEventListener('click', () => {
                if (playerArousalLevel < maxArousal) {
                    playerArousalLevel++;
                    updateArousalDisplay();
                    showMessage("เพิ่มระดับความเงี่ยน", 'info');
                } else {
                    showMessage("ความเงี่ยนถึงระดับสูงสุดแล้ว!", 'info');
                }
            });

            decreaseArousalBtn.addEventListener('click', () => {
                if (playerArousalLevel > 1) {
                    playerArousalLevel--;
                    updateArousalDisplay();
                    showMessage("ลดระดับความเงี่ยน", 'info');
                } else {
                    showMessage("ความเงี่ยนถึงระดับต่ำสุดแล้ว!", 'info');
                }
            });

            playerOpenCameraBtn.addEventListener('click', () => startCamera());
            playerSwapCameraBtn.addEventListener('click', switchCamera);
            playerStopCameraBtn.addEventListener('click', stopCamera);

            playerSlowPleaseBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { room: myRoom, type: 'slow_please', message: 'Player: slow please' }); // Pass myRoom
                showMessage('ส่งคำขอ: Slow Please!', 'success');
            });
            playerICanCumBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { room: myRoom, type: 'i_can_cum', message: 'Player: I can cum' }); // Pass myRoom
                showMessage('ส่งคำขอ: I Can Cum!', 'success');
            });
            playerPleaseStopBtn.addEventListener('click', () => {
                socket.emit('playerCommand', { room: myRoom, type: 'please_stop', message: 'Player: please stop' }); // Pass myRoom
                showMessage('ส่งคำขอ: Please Stop!', 'success');
            });

            backToLobbyBtnPlayer.addEventListener('click', () => {
                showMessage("กำลังกลับสู่ล็อบบี้...", 'info');
                socket.emit('leaveRoom');
                if (peerConnection && peerConnection.connectionState !== 'closed') {
                    peerConnection.close();
                    peerConnection = null;
                    videoSender = null;
                }
                stopCamera();
                remoteVideo.srcObject = null;
                remoteVideo.style.display = 'none';
                if (playerElapsedTimeInterval) {
                    clearInterval(playerElapsedTimeInterval);
                    playerElapsedTimeInterval = null;
                }
                if (strokeInterval) {
                    clearInterval(strokeInterval);
                    strokeInterval = null;
                    strokeVisualizer.style.height = '0%';
                    strokeVisualizer.classList.remove('stroke-pulse');
                }
                setTimeout(() => {
                    window.location.href = '/lobby.html';
                }, 1500);
            });

            window.addEventListener('resize', syncStrokeVisualizerHeight);
        });

        // Socket.IO Listeners for game commands from Master
        socket.on('masterCommand', (data) => {
            console.log("Player received command from Master:", data);
            if (data.type === 'cum_now') {
                showMessage("Master สั่งให้คุณหลั่ง! 💦💦💦", 'success');
                playerArousalLevel = maxArousal;
                updateArousalDisplay();
            } else if (data.type === 'dont_touch') {
                showMessage(data.message, 'error');
            } else if (data.type === 'ok' || data.type === 'no') {
                showMessage(data.message, 'info');
            } else if (data.type === 'bpm_update') {
                animateStrokeVisualizer(data.bpm);
                showMessage(`ความเร็ว: ${data.bpm} BPM`, 'info');
            } else if (data.type === 'bpm_stop') {
                animateStrokeVisualizer(0);
                showMessage("Master สั่งหยุด!", 'info');
            } else if (data.type === 'bpm_start') {
                animateStrokeVisualizer(data.bpm);
                showMessage("Master สั่งเริ่ม!", 'info');
            }
        });

        // Handle initial connection or reconnection - server typically sends 'paired'
        socket.on('connect', () => {
            console.log('Player connected to Socket.IO server.');
        });

        socket.on('disconnect', () => {
            console.log('Player disconnected from Socket.IO server.');
        });
    </script>
</body>
</html>
